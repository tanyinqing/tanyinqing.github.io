<!DOCTYPE html>

<html>

<head>

<title>安卓疯狂讲义书籍</title>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<style type="text/css">

/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */

/* Author: Nicolas Hery - http://nicolashery.com */

/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */

/* Source: https://github.com/nicolahery/markdownpad-github */



/* RESET

=============================================================================*/



html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {

  margin: 0;

  padding: 0;

  border: 0;

}



/* BODY

=============================================================================*/



body {

  font-family: Helvetica, arial, freesans, clean, sans-serif;

  font-size: 14px;

  line-height: 1.6;

  color: #333;

  background-color: #fff;

  padding: 20px;

  max-width: 960px;

  margin: 0 auto;

}



body>*:first-child {

  margin-top: 0 !important;

}



body>*:last-child {

  margin-bottom: 0 !important;

}



/* BLOCKS

=============================================================================*/



p, blockquote, ul, ol, dl, table, pre {

  margin: 15px 0;

}



/* HEADERS

=============================================================================*/



h1, h2, h3, h4, h5, h6 {

  margin: 20px 0 10px;

  padding: 0;

  font-weight: bold;

  -webkit-font-smoothing: antialiased;

}



h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {

  font-size: inherit;

}



h1 {

  font-size: 28px;

  color: #000;

}



h2 {

  font-size: 24px;

  border-bottom: 1px solid #ccc;

  color: #000;

}



h3 {

  font-size: 18px;

}



h4 {

  font-size: 16px;

}



h5 {

  font-size: 14px;

}



h6 {

  color: #777;

  font-size: 14px;

}



body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {

  margin-top: 0;

  padding-top: 0;

}



a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {

  margin-top: 0;

  padding-top: 0;

}



h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {

  margin-top: 10px;

}



/* LINKS

=============================================================================*/



a {

  color: #4183C4;

  text-decoration: none;

}



a:hover {

  text-decoration: underline;

}



/* LISTS

=============================================================================*/



ul, ol {

  padding-left: 30px;

}



ul li > :first-child, 

ol li > :first-child, 

ul li ul:first-of-type, 

ol li ol:first-of-type, 

ul li ol:first-of-type, 

ol li ul:first-of-type {

  margin-top: 0px;

}



ul ul, ul ol, ol ol, ol ul {

  margin-bottom: 0;

}



dl {

  padding: 0;

}



dl dt {

  font-size: 14px;

  font-weight: bold;

  font-style: italic;

  padding: 0;

  margin: 15px 0 5px;

}



dl dt:first-child {

  padding: 0;

}



dl dt>:first-child {

  margin-top: 0px;

}



dl dt>:last-child {

  margin-bottom: 0px;

}



dl dd {

  margin: 0 0 15px;

  padding: 0 15px;

}



dl dd>:first-child {

  margin-top: 0px;

}



dl dd>:last-child {

  margin-bottom: 0px;

}



/* CODE

=============================================================================*/



pre, code, tt {

  font-size: 12px;

  font-family: Consolas, "Liberation Mono", Courier, monospace;

}



code, tt {

  margin: 0 0px;

  padding: 0px 0px;

  white-space: nowrap;

  border: 1px solid #eaeaea;

  background-color: #f8f8f8;

  border-radius: 3px;

}



pre>code {

  margin: 0;

  padding: 0;

  white-space: pre;

  border: none;

  background: transparent;

}



pre {

  background-color: #f8f8f8;

  border: 1px solid #ccc;

  font-size: 13px;

  line-height: 19px;

  overflow: auto;

  padding: 6px 10px;

  border-radius: 3px;

}



pre code, pre tt {

  background-color: transparent;

  border: none;

}



kbd {

    -moz-border-bottom-colors: none;

    -moz-border-left-colors: none;

    -moz-border-right-colors: none;

    -moz-border-top-colors: none;

    background-color: #DDDDDD;

    background-image: linear-gradient(#F1F1F1, #DDDDDD);

    background-repeat: repeat-x;

    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;

    border-image: none;

    border-radius: 2px 2px 2px 2px;

    border-style: solid;

    border-width: 1px;

    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;

    line-height: 10px;

    padding: 1px 4px;

}



/* QUOTES

=============================================================================*/



blockquote {

  border-left: 4px solid #DDD;

  padding: 0 15px;

  color: #777;

}



blockquote>:first-child {

  margin-top: 0px;

}



blockquote>:last-child {

  margin-bottom: 0px;

}



/* HORIZONTAL RULES

=============================================================================*/



hr {

  clear: both;

  margin: 15px 0;

  height: 0px;

  overflow: hidden;

  border: none;

  background: transparent;

  border-bottom: 4px solid #ddd;

  padding: 0;

}



/* TABLES

=============================================================================*/



table th {

  font-weight: bold;

}



table th, table td {

  border: 1px solid #ccc;

  padding: 6px 13px;

}



table tr {

  border-top: 1px solid #ccc;

  background-color: #fff;

}



table tr:nth-child(2n) {

  background-color: #f8f8f8;

}



/* IMAGES

=============================================================================*/



img {

  max-width: 100%

}

</style>

<style type="text/css">

.highlight  { background: #ffffff; }

.highlight .c { color: #999988; font-style: italic } /* Comment */

.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */

.highlight .k { font-weight: bold } /* Keyword */

.highlight .o { font-weight: bold } /* Operator */

.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */

.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */

.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */

.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */

.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */

.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */

.highlight .ge { font-style: italic } /* Generic.Emph */

.highlight .gr { color: #aa0000 } /* Generic.Error */

.highlight .gh { color: #999999 } /* Generic.Heading */

.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */

.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */

.highlight .go { color: #888888 } /* Generic.Output */

.highlight .gp { color: #555555 } /* Generic.Prompt */

.highlight .gs { font-weight: bold } /* Generic.Strong */

.highlight .gu { color: #aaaaaa } /* Generic.Subheading */

.highlight .gt { color: #aa0000 } /* Generic.Traceback */

.highlight .kc { font-weight: bold } /* Keyword.Constant */

.highlight .kd { font-weight: bold } /* Keyword.Declaration */

.highlight .kp { font-weight: bold } /* Keyword.Pseudo */

.highlight .kr { font-weight: bold } /* Keyword.Reserved */

.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */

.highlight .m { color: #009999 } /* Literal.Number */

.highlight .s { color: #d14 } /* Literal.String */

.highlight .na { color: #008080 } /* Name.Attribute */

.highlight .nb { color: #0086B3 } /* Name.Builtin */

.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */

.highlight .no { color: #008080 } /* Name.Constant */

.highlight .ni { color: #800080 } /* Name.Entity */

.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */

.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */

.highlight .nn { color: #555555 } /* Name.Namespace */

.highlight .nt { color: #000080 } /* Name.Tag */

.highlight .nv { color: #008080 } /* Name.Variable */

.highlight .ow { font-weight: bold } /* Operator.Word */

.highlight .w { color: #bbbbbb } /* Text.Whitespace */

.highlight .mf { color: #009999 } /* Literal.Number.Float */

.highlight .mh { color: #009999 } /* Literal.Number.Hex */

.highlight .mi { color: #009999 } /* Literal.Number.Integer */

.highlight .mo { color: #009999 } /* Literal.Number.Oct */

.highlight .sb { color: #d14 } /* Literal.String.Backtick */

.highlight .sc { color: #d14 } /* Literal.String.Char */

.highlight .sd { color: #d14 } /* Literal.String.Doc */

.highlight .s2 { color: #d14 } /* Literal.String.Double */

.highlight .se { color: #d14 } /* Literal.String.Escape */

.highlight .sh { color: #d14 } /* Literal.String.Heredoc */

.highlight .si { color: #d14 } /* Literal.String.Interpol */

.highlight .sx { color: #d14 } /* Literal.String.Other */

.highlight .sr { color: #009926 } /* Literal.String.Regex */

.highlight .s1 { color: #d14 } /* Literal.String.Single */

.highlight .ss { color: #990073 } /* Literal.String.Symbol */

.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */

.highlight .vc { color: #008080 } /* Name.Variable.Class */

.highlight .vg { color: #008080 } /* Name.Variable.Global */

.highlight .vi { color: #008080 } /* Name.Variable.Instance */

.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */

.pl-c {

    color: #969896;

}



.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {

    color: #0086b3;

}



.pl-e,.pl-en {

    color: #795da3;

}



.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {

    color: #333;

}



.pl-ent {

    color: #63a35c;

}



.pl-k,.pl-s,.pl-st {

    color: #a71d5d;

}



.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {

    color: #df5000;

}



.pl-id {

    color: #b52a1d;

}



.pl-ii {

    background-color: #b52a1d;

    color: #f8f8f8;

}



.pl-sr .pl-cce {

    color: #63a35c;

    font-weight: bold;

}



.pl-ml {

    color: #693a17;

}



.pl-mh,.pl-mh .pl-en,.pl-ms {

    color: #1d3e81;

    font-weight: bold;

}



.pl-mq {

    color: #008080;

}



.pl-mi {

    color: #333;

    font-style: italic;

}



.pl-mb {

    color: #333;

    font-weight: bold;

}



.pl-md,.pl-mdhf {

    background-color: #ffecec;

    color: #bd2c00;

}



.pl-mdht,.pl-mi1 {

    background-color: #eaffea;

    color: #55a532;

}



.pl-mdr {

    color: #795da3;

    font-weight: bold;

}



.pl-mo {

    color: #1d3e81;

}

.task-list {

padding-left:10px;

margin-bottom:0;

}



.task-list li {

    margin-left: 20px;

}



.task-list-item {

list-style-type:none;

padding-left:10px;

}



.task-list-item label {

font-weight:400;

}



.task-list-item.enabled label {

cursor:pointer;

}



.task-list-item+.task-list-item {

margin-top:3px;

}



.task-list-item-checkbox {

display:inline-block;

margin-left:-20px;

margin-right:3px;

vertical-align:1px;

}

</style>

</head>

<body>

<h1 id="2017-08-17">2017 08 17</h1>
<blockquote>
<p> <a href="http://pan.baidu.com/disk/home?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;#list/vmode=list&amp;path=%2F%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%B9%2F%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%2FMarkDown%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3" title="查看">文档地址</a>→<a href="http://pan.baidu.com/disk/home?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;#list/vmode=list&amp;path=%2F%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%B9%2F%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%2FAndBaseDemo%E6%A1%86%E6%9E%B6" title="查看">源文件相关</a>→<a href="https://tanyinqing.github.io/">首页</a></p>
</blockquote>
<h1 id="1">目录1</h1> 

<ul>
<li><h3 id="1-">1应用和环境→</h3>
</li><li><h3 id="2-">2界面编程→</h3>
</li><li><h3 id="3-">3事件处理→</h3>
</li><li><h3 id="4activity-fragment-">4Activity与Fragment→</h3>
</li><li><h3 id="5-">5意图和意图过滤器通信→</h3>
</li><li><h3 id="6-">6资源→</h3>
</li><li><h3 id="7-">7图形与图像处理→</h3>
</li></ul>
<h1 id="2">目录2</h1>  

<ul>
<li><h3 id="8-io-">8数据存储与io→</h3>
</li><li><h3 id="9contentprovider-">9ContentProvider实现数据共享→</h3>
</li><li><h3 id="10-1001-intentservice-1002-1003-1004-1005-1006-1007-1008-1009-">10 服务与广播→<a href="#1001">绑定服务并通信</a>→<a href="#1002">IntentService</a>→<a href="#1003">电话管理器</a>→<a href="#1004">短信管理器</a>→<a href="#1005">音频管理器</a>→<a href="#1006">振动管理器</a>→<a href="#1007">手机闹钟服务</a>→<a href="#1008">接受广播服务</a>→<a href="#1009">接受系统广播</a></h3>
</li></ul>
<ul>
<li><h3 id="11-">11多媒体应用开发→</h3>
</li><li><h3 id="12-opengl-3d-">12 OpenGL与3D开发→</h3>
</li><li><h3 id="13-">13 网络应用→</h3>
</li><li><h3 id="14-">14 管理手机桌面→</h3>
</li></ul>
<h1 id="3">目录3</h1> 

<ul>
<li><h3 id="15-">15 传感器应用开发→</h3>
</li><li><h3 id="16-gps-">16 GPS应用开发→</h3>
</li><li><h3 id="17-map-">17 高德map服务→</h3>
</li><li><h3 id="18-">18 合金弹头→</h3>
</li><li><h3 id="19-">19 电子拍卖系统→</h3>
</li></ul>
<h1 id="-">参考文档</h1>
<p> <a href="http://pan.baidu.com/disk/home?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;#list/vmode=list&amp;path=%2F%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%B9%2F%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97" title="查看">百度项目地址</a></p>
<h1 id="1001">1. 绑定服务并通信</h1>

<p><a href="#2">返回目录</a> </p>
<p>服务的运行流程是<br>先服务自己创建，绑定，然后界面和服务连接成功<br>然后服务自己解绑，和销毁</p>
<p><img src="http://i.imgur.com/zGWAF2M.jpg" alt=""><br><img src="http://i.imgur.com/LhNCj79.jpg" alt=""><br>服务的注册</p>
<pre><code>  &lt;service android:name=&quot;.BindService&quot;&gt;
        &lt;/service&gt;
</code></pre><p>绑定服务并通信  <a href="#1001_1">服务的自定义</a></p>
<pre><code>package utilcode.tyq.com.ceshi4;

import android.app.Activity;
import android.app.Service;
import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;

public class MainActivity extends Activity
{
    Button bind, unbind, getServiceStatus;
    // 保持所启动的Service的IBinder对象 启动成功后返回给调用者的一个对象 连接成功是实例化
    BindService.MyBinder binder;
    // 定义一个ServiceConnection对象  监听Activity与服务的连接情况
    private ServiceConnection conn = new ServiceConnection()
    {
        // 当该Activity与Service连接成功时回调该方法
        @Override
        public void onServiceConnected(ComponentName name
                , IBinder service)
        {
            System.out.println(&quot;--Service Connected--&quot;);
            // 获取Service的onBind方法所返回的MyBinder对象
            binder = (BindService.MyBinder) service;  // ①
        }
        // 当该Activity与Service由于异常情况断开连接时回调该方法
        @Override
        public void onServiceDisconnected(ComponentName name)
        {
            System.out.println(&quot;--Service Disconnected--&quot;);
        }
    };
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取程序界面中的start、stop、getServiceStatus按钮
        bind = (Button) findViewById(R.id.bind);
        unbind = (Button) findViewById(R.id.unbind);
        getServiceStatus = (Button) findViewById(R.id.getServiceStatus);
        // 创建启动Service的Intent
        final Intent intent = new Intent(this, BindService.class);
        bind.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 绑定指定Service  Service.BIND_AUTO_CREATE表示服务未创建就创建一个服务
                // 把监听器放到服务中
                bindService(intent, conn, Service.BIND_AUTO_CREATE);
            }
        });
        unbind.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 解除绑定Service  这个是content中的方法 释放监听器
                unbindService(conn);
            }
        });
        getServiceStatus.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 获取、并显示Service的count值 Activity与服务之间对象的传递
                Toast.makeText(MainActivity.this,
                        &quot;Service的count值为：&quot; + binder.getCount(),
                        Toast.LENGTH_SHORT).show();  // ②
            }
        });
    }
}
</code></pre><h1 id="1001_1">1. 服务的自定义</h1>

<p><a href="#1001">返回目录</a> </p>
<pre><code>package utilcode.tyq.com.ceshi4;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;

public class BindService extends Service
{
    private int count;
    private boolean quit;
    // 定义onBinder方法所返回的对象
    private MyBinder binder = new MyBinder();
    // 通过继承Binder来实现IBinder类
    public class MyBinder extends Binder  // ①
    {
        //继承类，并自定义一个方法
        public int getCount()
        {
            // 获取Service的运行状态：count
            return count;
        }
    }
    // 必须实现的方法，绑定该Service时回调该方法
    @Override
    public IBinder onBind(Intent intent)
    {
        System.out.println(&quot;Service is Binded&quot;);
        // 返回IBinder对象
        return binder;
    }
    // Service被创建时回调该方法
    @Override
    public void onCreate()
    {
        super.onCreate();
        System.out.println(&quot;Service is Created&quot;);
        // 启动一条线程，动态地修改count状态值
        new Thread()
        {
            @Override
            public void run()
            {
                while (!quit)
                {
                    try
                    {
                        Thread.sleep(1000);
                    }
                    catch (InterruptedException e)
                    {
                    }
                    count++;
                }
            }
        }.start();
    }
    // Service被断开连接时回调该方法
    @Override
    public boolean onUnbind(Intent intent)
    {
        System.out.println(&quot;Service is Unbinded&quot;);
        return true;
    }
    // Service被关闭之前回调该方法
    @Override
    public void onDestroy()
    {
        super.onDestroy();
        this.quit = true;
        System.out.println(&quot;Service is Destroyed&quot;);
    }
}
</code></pre><h1 id="1002">2. IntentService</h1>

<p><a href="#2">返回目录</a> </p>
<p>IntentService会创建单独的worer线程来处理所有的Intent请求。<br>处理完成后，会自动终止线程。<br><img src="http://i.imgur.com/qhl9bxI.jpg" alt=""></p>
<p>启动服务的代码</p>
<pre><code>public void startService(View source)
    {
        // 创建需要启动的Service的Intent
        Intent intent = new Intent(this, MyService.class);
        // 启动Service
        startService(intent);
    }
    public void startIntentService(View source)
    {
        // 创建需要启动的IntentService的Intent
        Intent intent = new Intent(this, MyIntentService.class);
        // 启动IntentService
        startService(intent);
    }
</code></pre><p>普通服务</p>
<pre><code>package org.crazyit.service;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;

public class MyService extends Service
{
    @Override
    public IBinder onBind(Intent intent)
    {
        return null;
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId)
    {
        // 该方法内执行耗时任务可能导致ANR（Application Not Responding）异常
        long endTime = System.currentTimeMillis() + 20 * 1000;
        System.out.println(&quot;onStart&quot;);
        while (System.currentTimeMillis() &lt; endTime)
        {
            synchronized (this)
            {
                try
                {
                    wait(endTime - System.currentTimeMillis());
                }
                catch (Exception e)
                {
                }
            }
        }
        System.out.println(&quot;---耗时任务执行完成---&quot;);
        return START_STICKY;
    }
}
</code></pre><p>IntentService的实现</p>
<pre><code>package org.crazyit.service;

import android.app.IntentService;
import android.content.Intent;

public class MyIntentService extends IntentService
{
    public MyIntentService()
    {
        super(&quot;MyIntentService&quot;);
    }
    // IntentService会使用单独的线程来执行该方法的代码
    @Override
    protected void onHandleIntent(Intent intent)
    {
        // 该方法内可以执行任何耗时任务，比如下载文件等，此处只是让线程暂停20秒
        long endTime = System.currentTimeMillis() + 20 * 1000;
        System.out.println(&quot;onStartCommand&quot;);
        while (System.currentTimeMillis() &lt; endTime)
        {//线程暂停
            synchronized (this)
            {
                try
                {
                    wait(endTime - System.currentTimeMillis());
                }
                catch (Exception e)
                {
                }
            }
        }
        System.out.println(&quot;---耗时任务执行完成---&quot;);
    }
}
</code></pre><h1 id="1003">1. 电话管理器</h1>

<p><a href="#2">返回目录</a> </p>
<p>SimpleAdapter 适配器的运用<br>需要权限</p>
<p><a href="1003_1">监听手机来电</a></p>
<p><img src="http://i.imgur.com/QUch1T7.jpg" alt=""><br>列表</p>
<pre><code>&lt;ListView 
    android:id=&quot;@+id/show&quot;
    android:layout_width=&quot;match_parent&quot; 
    android:layout_height=&quot;match_parent&quot; 
    android:entries=&quot;@array/statusNames&quot;
    /&gt;
</code></pre><p>字符串列表</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;!-- 声明一个名为statusNames的字符串数组 --&gt;
    &lt;string-array name=&quot;statusNames&quot;&gt;
        &lt;item&gt;设备编号&lt;/item&gt;
        &lt;item&gt;软件版本&lt;/item&gt;
        &lt;item&gt;网络运营商代号&lt;/item&gt;
        &lt;item&gt;网络运营商名称&lt;/item&gt;
        &lt;item&gt;手机制式&lt;/item&gt;
        &lt;item&gt;设备当前位置&lt;/item&gt;
        &lt;item&gt;SIM卡的国别&lt;/item&gt;
        &lt;item&gt;SIM卡序列号&lt;/item&gt;
        &lt;item&gt;SIM卡状态&lt;/item&gt;        
    &lt;/string-array&gt;
    &lt;!-- 声明一个名为simState的字符串数组 --&gt;
    &lt;string-array name=&quot;simState&quot;&gt;
        &lt;item&gt;状态未知&lt;/item&gt;
        &lt;item&gt;无SIM卡&lt;/item&gt;
        &lt;item&gt;被PIN加锁&lt;/item&gt;
        &lt;item&gt;被PUK加锁&lt;/item&gt;
        &lt;item&gt;被NetWork PIN加锁&lt;/item&gt;
        &lt;item&gt;已准备好&lt;/item&gt;
    &lt;/string-array&gt;
    &lt;!-- 声明一个名为phoneType的字符串数组 --&gt;
    &lt;string-array name=&quot;phoneType&quot;&gt;    
        &lt;item&gt;未知&lt;/item&gt;
        &lt;item&gt;GSM&lt;/item&gt;
        &lt;item&gt;CDMA&lt;/item&gt;
    &lt;/string-array&gt;    
&lt;/resources&gt;
</code></pre><p>源代码实现</p>
<pre><code>package utilcode.tyq.com.ceshi4;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.telephony.TelephonyManager;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ListView;
import android.widget.SimpleAdapter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;


public class MainActivity extends Activity
{
    ListView showView;
    // 声明代表状态名的数组
    String[] statusNames;
    // 声明代表手机状态的集合
    ArrayList&lt;String&gt; statusValues = new ArrayList&lt;&gt;();
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取系统的TelephonyManager对象
        TelephonyManager tManager = (TelephonyManager)
                getSystemService(Context.TELEPHONY_SERVICE);
        // 获取各种状态名称的数组
        statusNames = getResources().getStringArray(R.array.statusNames);
        // 获取代表SIM卡状态的数组
        String[] simState = getResources()
                .getStringArray(R.array.simState);
        // 获取代表电话网络类型的数组
        String[] phoneType = getResources().getStringArray(
                R.array.phoneType);
        // 获取设备编号
        statusValues.add(tManager.getDeviceId());
        // 获取系统平台的版本
        statusValues.add(tManager.getDeviceSoftwareVersion()
                != null ? tManager.getDeviceSoftwareVersion() : &quot;未知&quot;);
        // 获取网络运营商代号
        statusValues.add(tManager.getNetworkOperator());
        // 获取网络运营商名称
        statusValues.add(tManager.getNetworkOperatorName());
        // 获取手机网络类型
        statusValues.add(phoneType[tManager.getPhoneType()]);
        // 获取设备所在位置
        statusValues.add(tManager.getCellLocation() != null ? tManager
                .getCellLocation().toString() : &quot;未知位置&quot;);
        // 获取SIM卡的国别
        statusValues.add(tManager.getSimCountryIso());
        // 获取SIM卡序列号
        statusValues.add(tManager.getSimSerialNumber());
        // 获取SIM卡状态
        statusValues.add(simState[tManager.getSimState()]);
        // 获得ListView对象
        showView = (ListView) findViewById(R.id.show);
        ArrayList&lt;Map&lt;String, String&gt;&gt; status = new ArrayList&lt;&gt;();
        // 遍历statusValues集合，将statusNames、statusValues
        // 的数据封装到List&lt;Map&lt;String , String&gt;&gt;集合中
        for (int i = 0; i &lt; statusValues.size(); i++)
        {
            HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
            map.put(&quot;name&quot;, statusNames[i]);
            map.put(&quot;value&quot;, statusValues.get(i));
            status.add(map);
        }
        // 使用SimpleAdapter封装List数据
        SimpleAdapter adapter = new SimpleAdapter(this, status,
                R.layout.line, new String[] { &quot;name&quot;, &quot;value&quot; }
                , new int[] { R.id.name, R.id.value });
        // 为ListView设置Adapter
        showView.setAdapter(adapter);
    }
}
</code></pre><h1 id="1003_1">1. 监听手机来电</h1>

<p><a href="#1003">返回目录</a> </p>
<p>需要权限</p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.telephony.PhoneStateListener;
import android.telephony.TelephonyManager;

import java.io.FileNotFoundException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Date;

public class MainActivity extends Activity
{
    TelephonyManager tManager;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 取得TelephonyManager对象
        tManager = (TelephonyManager)
                getSystemService(Context.TELEPHONY_SERVICE);
        // 创建一个通话状态监听器
        PhoneStateListener listener = new PhoneStateListener()
        {
            @Override
            public void onCallStateChanged(int state, String number)
            {
                switch (state)
                {
                    // 无任何状态
                    case TelephonyManager.CALL_STATE_IDLE:
                        break;
                    case TelephonyManager.CALL_STATE_OFFHOOK:
                        break;
                    // 来电铃响时
                    case TelephonyManager.CALL_STATE_RINGING:
                        OutputStream os = null;
                        try
                        {
                            os = openFileOutput(&quot;phoneList&quot;, MODE_APPEND);
                        }
                        catch (FileNotFoundException e)
                        {
                            e.printStackTrace();
                        }
                        PrintStream ps = new PrintStream(os);
                        // 将来电号码记录到文件中
                        ps.println(new Date() + &quot; 来电：&quot; + number);
                        ps.close();
                        break;
                    default:
                        break;
                }
                super.onCallStateChanged(state, number);
            }
        };
        // 监听电话通话状态的改变
        tManager.listen(listener, PhoneStateListener.LISTEN_CALL_STATE);
    }
}
</code></pre><h1 id="1004">1. 短信管理器</h1>

<p><a href="#2">返回目录</a> </p>
<p>发送短信 需要权限</p>
<pre><code>    // 创建一个PendingIntent对象
                PendingIntent pi = PendingIntent.getActivity(
                        MainActivity.this, 0, new Intent(), 0);
                // 发送短信 分别获取收件人和内容
                sManager.sendTextMessage(number.getText().toString(),
                        null, content.getText().toString(), pi, null);
                // 提示短信发送完成
                Toast.makeText(MainActivity.this, &quot;短信发送完成&quot;, 8000).show();
</code></pre><p>群发短信<br><img src="http://i.imgur.com/ZgqQm2u.png" alt=""></p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.PendingIntent;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.os.Bundle;
import android.provider.ContactsContract;
import android.telephony.SmsManager;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.Toast;

import java.util.ArrayList;


public class MainActivity extends Activity
{
    EditText numbers, content;
    Button select, send;
    SmsManager sManager;
    // 记录需要群发的号码列表
    ArrayList&lt;String&gt; sendList = new ArrayList&lt;String&gt;();
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        sManager = SmsManager.getDefault();
        // 获取界面上的文本框、按钮组件
        numbers = (EditText) findViewById(R.id.numbers);
        content = (EditText) findViewById(R.id.content);
        select = (Button) findViewById(R.id.select);
        send = (Button) findViewById(R.id.send);
        // 为send按钮的单击事件绑定监听器
        send.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                for (String number : sendList)
                {
                    // 创建一个PendingIntent对象
                    PendingIntent pi = PendingIntent.getActivity(
                            MainActivity.this, 0, new Intent(), 0);
                    // 发送短信
                    sManager.sendTextMessage(number, null, content
                            .getText().toString(), pi, null);
                }
                // 提示短信群发完成
                Toast.makeText(MainActivity.this, &quot;短信群发完成&quot;
                        , Toast.LENGTH_SHORT).show();
            }
        });
        // 为select按钮的单击事件绑定监听器
        select.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                // 查询联系人的电话号码 从公共资源中查询联系人
                final Cursor cursor = getContentResolver().query(
                        ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
                        null, null, null, null);
                BaseAdapter adapter = new BaseAdapter()
                {
                    @Override
                    public int getCount()
                    {
                        return cursor.getCount();
                    }
                    @Override
                    public Object getItem(int position)
                    {
                        return position;
                    }
                    @Override
                    public long getItemId(int position)
                    {
                        return position;
                    }
                    @Override
                    public View getView(int position, View convertView,
                                        ViewGroup parent)
                    {
                        cursor.moveToPosition(position);
                        CheckBox rb = new CheckBox(MainActivity.this);
                        // 获取联系人的电话号码，并去掉中间的中画线、空格
                        String number = cursor
                                .getString(cursor.getColumnIndex(ContactsContract
                                        .CommonDataKinds.Phone.NUMBER))
                                .replace(&quot;-&quot;, &quot;&quot;)
                                .replace(&quot; &quot; , &quot;&quot;);
                        rb.setText(number);
                        // 如果该号码已经被加入发送人名单，默认勾选该号码
                        if (isChecked(number))
                        {
                            rb.setChecked(true);
                        }
                        return rb;
                    }
                };
                // 加载list.xml布局文件对应的View
                View selectView = getLayoutInflater().inflate(
                        R.layout.list, null);
                // 获取selectView中的名为list的ListView组件
                final ListView listView = (ListView) selectView
                        .findViewById(R.id.list);
                listView.setAdapter(adapter);
//这个是弹出对话框的代码
                new AlertDialog.Builder(MainActivity.this)
                        .setView(selectView)
                        .setPositiveButton(&quot;确定&quot;,
                                new DialogInterface.OnClickListener()
                                {
                                    @Override
                                    public void onClick(DialogInterface dialog,
                                                        int which)
                                    {
                                        // 清空sendList集合
                                        sendList.clear();
                                        // 遍历listView组件的每个列表项
                                        for (int i = 0; i &lt; listView.getCount(); i++)
                                        {
                                            CheckBox checkBox = (CheckBox) listView
                                                    .getChildAt(i);
                                            // 如果该列表项被勾选
                                            if (checkBox.isChecked())
                                            {
                                                // 添加该列表项的电话号码
                                                sendList.add(checkBox.getText()
                                                        .toString());
                                            }
                                        }
                                        numbers.setText(sendList.toString());
                                    }
                                }).show();
            }
        });
    }
    // 判断某个电话号码是否已在群发范围内
    public boolean isChecked(String phone)
    {
        for (String s1 : sendList)
        {
            if (s1.equals(phone))
            {
                return true;
            }
        }
        return false;
    }
}
</code></pre><h1 id="1005">1. 音频管理器</h1>

<p><a href="#2">返回目录</a> </p>
<p><img src="http://i.imgur.com/OMa078T.jpg" alt=""></p>
<pre><code>测
</code></pre><h1 id="1001">1. 绑定服务并通信</h1>

<p><a href="#2">返回目录</a> </p>
<p>静音或正常的按钮</p>
<pre><code>&lt;ToggleButton
    android:id=&quot;@+id/mute&quot;
    android:layout_width=&quot;wrap_content&quot; 
    android:layout_height=&quot;wrap_content&quot; 
    android:textOn=&quot;@string/normal&quot;
    android:textOff=&quot;@string/mute&quot;
/&gt;
</code></pre><p>实现的代码</p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.Service;
import android.media.AudioManager;
import android.media.MediaPlayer;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ToggleButton;


public class MainActivity extends Activity
{
    Button play, up, down;
    ToggleButton mute;
    AudioManager aManager;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取系统的音频服务
        aManager = (AudioManager) getSystemService(
                Service.AUDIO_SERVICE);
        // 获取界面中三个按钮和一个ToggleButton控件
        play = (Button) findViewById(R.id.play);
        up = (Button) findViewById(R.id.up);
        down = (Button) findViewById(R.id.down);
        mute = (ToggleButton) findViewById(R.id.mute);
        // 为play按钮的单击事件绑定监听器
        play.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                //从raw文件夹中读取文件
                // 初始化MediaPlayer对象，准备播放音乐
                MediaPlayer mPlayer = MediaPlayer.create(
                        MainActivity.this, R.raw.earth);
                // 设置循环播放
                mPlayer.setLooping(true);
                // 开始播放
                mPlayer.start();
            }
        });
        up.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // STREAM_MUSIC指定调节音乐的音频，ADJUST_RAISE增大音量，FLAG_SHOW_UI而且显示音量图形示意
                aManager.adjustStreamVolume(AudioManager.STREAM_MUSIC,
                        AudioManager.ADJUST_RAISE, AudioManager.FLAG_SHOW_UI);
            }
        });
        down.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 指定调节音乐的音频，降低音量，而且显示音量图形示意
                aManager.adjustStreamVolume(AudioManager.STREAM_MUSIC,
                        AudioManager.ADJUST_LOWER, AudioManager.FLAG_SHOW_UI);
            }
        });
        mute.setOnCheckedChangeListener(new OnCheckedChangeListener()
        {
            @Override
            public void onCheckedChanged(CompoundButton source,
                                         boolean isChecked)
            {
                // 指定调节音乐的音频，根据isChecked确定是否需要静音
                aManager.setStreamMute(AudioManager.STREAM_MUSIC,
                        isChecked);
            }
        });
    }
}
</code></pre><h1 id="1006">1. 振动管理器</h1>

<p><a href="#2">返回目录</a> </p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.Service;
import android.os.Bundle;
import android.os.Vibrator;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.widget.Toast;


public class MainActivity extends Activity
{
    Vibrator vibrator;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取系统的Vibrator服务
        vibrator = (Vibrator) getSystemService(
                Service.VIBRATOR_SERVICE);
    }
    // 重写onTouchEvent方法，当用户触碰触摸屏时触发该方法
    @Override
    public boolean onTouchEvent(MotionEvent event)
    {
        Toast.makeText(this, &quot;手机振动&quot;
                , Toast.LENGTH_SHORT).show();
        // 控制手机振动2秒
        vibrator.vibrate(2000);
        return super.onTouchEvent(event);
    }
}
</code></pre><h1 id="1007">1. 手机闹钟服务</h1>

<p><a href="#2">返回目录</a> </p>
<p><a href="#1007_1">定时更换壁纸</a></p>
<p>全局定时器使用，当宿主进程被杀死以后，运行在宿主进程上的组件也就不存在了。<br>如果进程关闭了，闹钟就不响了<br><img src="http://i.imgur.com/dF7XCtu.jpg" alt=""></p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.media.MediaPlayer;
import android.os.Bundle;

public class AlarmActivity extends Activity
{
    MediaPlayer alarmMusic;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        // 加载指定音乐，并为之创建MediaPlayer对象
        alarmMusic = MediaPlayer.create(this, R.raw.alarm);
        alarmMusic.setLooping(true);
        // 播放音乐
        alarmMusic.start();
        // 创建一个对话框
        new AlertDialog.Builder(AlarmActivity.this).setTitle(&quot;闹钟&quot;)
                .setMessage(&quot;闹钟响了,Go！Go！Go！&quot;)
                .setPositiveButton(&quot;确定&quot;, new OnClickListener()
                {
                    @Override
                    public void onClick(DialogInterface dialog, int which)
                    {
                        // 停止音乐
                        alarmMusic.stop();
                        // 结束该Activity
                        AlarmActivity.this.finish();
                    }
                }).show();
    }
}
</code></pre><p><img src="http://i.imgur.com/qVYss4F.jpg" alt=""></p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.TimePickerDialog;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.TimePicker;
import android.widget.Toast;

import java.util.Calendar;

public class MainActivity extends Activity
{
    Button setTime;
    Calendar currentTime = Calendar.getInstance();
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取程序界面的按钮
        setTime = (Button) findViewById(R.id.setTime);
        // 为“设置闹铃”按钮绑定监听器。
        setTime.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                Calendar currentTime = Calendar.getInstance();
                // 创建一个TimePickerDialog实例，并把它显示出来。
                new TimePickerDialog(MainActivity.this, 0, // 绑定监听器
                    new TimePickerDialog.OnTimeSetListener()
                    {
                        @Override
                        public void onTimeSet(TimePicker tp,
                            int hourOfDay, int minute)
                        {
                            // 指定启动AlarmActivity组件
                            Intent intent = new Intent(MainActivity.this,
                                AlarmActivity.class);
                            // 创建PendingIntent对象  打开一个Activity页面
                            PendingIntent pi = PendingIntent.getActivity(
                                    MainActivity.this, 0, intent, 0);
                            分割时间
                            Calendar c = Calendar.getInstance();
                            c.setTimeInMillis(System.currentTimeMillis());
                            // 根据用户选择时间来设置Calendar对象
                            c.set(Calendar.HOUR, hourOfDay);
                            c.set(Calendar.MINUTE, minute);
                            // 获取AlarmManager对象
                            AlarmManager aManager = (AlarmManager)
                                getSystemService(ALARM_SERVICE);
                            // 设置AlarmManager将在Calendar对应的时间启动指定组件
                            aManager.set(AlarmManager.RTC_WAKEUP,
                                    c.getTimeInMillis(), pi);
                            // 显示闹铃设置成功的提示信息
                            Toast.makeText(MainActivity.this, &quot;闹铃设置成功啦&quot;
                                , Toast.LENGTH_SHORT).show();
                        }
                    }, currentTime.get(Calendar.HOUR_OF_DAY), currentTime
                    .get(Calendar.MINUTE), false).show();
            }
        });
    }
}
</code></pre><h1 id="1007_1">1. 定时更换壁纸</h1>

<p><a href="#1007">返回目录</a> </p>
<p>壁纸管理服务</p>
<pre><code>package org.crazyit.manager;

import android.app.Service;
import android.app.WallpaperManager;
import android.content.Intent;
import android.os.IBinder;

public class ChangeService extends Service
{
    // 定义定时更换的壁纸资源
    int[] wallpapers = new int[]{
            R.drawable.shuangta,
            R.drawable.lijiang,
            R.drawable.qiao,
            R.drawable.shui
    };
    // 定义系统的壁纸管理服务
    WallpaperManager wManager;
    // 定义当前所显示的壁纸
    int current = 0;
    @Override
    public int onStartCommand(Intent intent, int flags, int startId)
    {
        // 如果到了最后一张，系统重新开始
        if(current &gt;= 4)
            current = 0;
        try
        {
            // 改变壁纸
            wManager.setResource(wallpapers[current++]);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return START_STICKY;
    }
    @Override
    public void onCreate()
    {
        super.onCreate();
        // 初始化WallpaperManager
        wManager = WallpaperManager.getInstance(this);
    }
    @Override
    public IBinder onBind(Intent intent)
    {
        return null;
    }
}
</code></pre><p>每5秒钟去启动一个服务</p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;


public class MainActivity extends Activity
{
    Button start, stop;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        start = (Button) findViewById(R.id.start);
        stop = (Button) findViewById(R.id.stop);
        // 指定启动ChangeService组件
        Intent intent = new Intent(MainActivity.this, ChangeService.class);
        // 创建PendingIntent对象 定时去启动一个服务
        final PendingIntent pi = PendingIntent.getService(MainActivity.this, 0, intent, 0);
        start.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View arg0)
            {
                // 获取AlarmManager对象
                AlarmManager aManager = (AlarmManager) getSystemService(
                    Service.ALARM_SERVICE);
                // 设置每隔5秒执行pi代表的组件一次
                aManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP
                    , 0, 5000, pi);
                start.setEnabled(false);
                stop.setEnabled(true);
                Toast.makeText(MainActivity.this
                    , &quot;壁纸定时更换启动成功啦&quot;,
                    Toast.LENGTH_SHORT).show();
            }
        });
        stop.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View arg0)
            {
            start.setEnabled(true);
            stop.setEnabled(false);
            // 获取AlarmManager对象
            AlarmManager aManager = (AlarmManager) getSystemService(
                Service.ALARM_SERVICE);
            // 取消对pi的调度
            aManager.cancel(pi);
            }
        });
    }
}
</code></pre><h1 id="1008">1. 接受广播服务</h1>

<p><a href="#2">返回目录</a> </p>
<p>这是一个全局的、系统级别的监听器，拥有自己的进程。程序级别的监听器，当程序关闭后，就退出了。<br>如果进程内没有任何活动组件，当内存紧张时，就会有些接受该进程</p>
<p><a href="#1008_1">有序广播</a><br><a href="#1008_2">音乐播放器</a><br>后台负责播放音乐，前台进行控制。通过广播进行通信</p>
<p>简单的广播<br><img src="http://i.imgur.com/p1Sy47J.jpg" alt=""></p>
<pre><code>注册全局广播
&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;
            &lt;intent-filter&gt;
                &lt;!-- 指定该BroadcastReceiver所响应的Intent的Action --&gt;
                &lt;action android:name=&quot;org.crazyit.action.CRAZY_BROADCAST&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;


广播接受的实例
public class MyReceiver extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Toast.makeText(context,
            &quot;接收到的Intent的Action为：&quot; + intent.getAction()
            + &quot;\n消息内容是：&quot; + intent.getStringExtra(&quot;msg&quot;)
            , Toast.LENGTH_LONG).show();
    }
}

发送一条广播
send.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                // 创建Intent对象
                Intent intent = new Intent();
                // 设置Intent的Action属性
                intent.setAction(&quot;org.crazyit.action.CRAZY_BROADCAST&quot;);
                intent.putExtra(&quot;msg&quot;, &quot;简单的消息&quot;);
                // 发送广播
                sendBroadcast(intent);
            }
        });
</code></pre><h1 id="1008_1">1. 有序广播</h1>

<p><a href="#1008">返回目录</a> </p>
<p>注册优先级 两个广播的优先级不同</p>
<pre><code>&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;
            &lt;intent-filter android:priority=&quot;20&quot;&gt;
                &lt;action android:name=&quot;org.crazyit.action.CRAZY_BROADCAST&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;
        &lt;receiver android:name=&quot;.MyReceiver2&quot;&gt;
            &lt;intent-filter android:priority=&quot;0&quot;&gt;
                &lt;action android:name=&quot;org.crazyit.action.CRAZY_BROADCAST&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;
</code></pre><p>发送广播</p>
<pre><code>// 创建Intent对象
                Intent intent = new Intent();
                intent.setAction(&quot;org.crazyit.action.CRAZY_BROADCAST&quot;);
                intent.putExtra(&quot;msg&quot;, &quot;简单的消息&quot;);
                // 发送有序广播
                sendOrderedBroadcast(intent, null);
</code></pre><p>第二个广播</p>
<pre><code>public class MyReceiver2 extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Bundle bundle = getResultExtras(true);
        // 解析前一个BroadcastReceiver所存入的key为first的消息
        String first = bundle.getString(&quot;first&quot;);
        Toast.makeText(context, &quot;第一个Broadcast存入的消息为：&quot;
            + first, Toast.LENGTH_LONG).show();
    }
}
</code></pre><p>第一个广播</p>
<pre><code>public class MyReceiver extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Toast.makeText(context,    &quot;接收到的Intent的Action为：&quot;
                + intent.getAction() + &quot;\n消息内容是：&quot;
                + intent.getStringExtra(&quot;msg&quot;)
                , Toast.LENGTH_LONG).show();
        // 创建一个Bundle对象，并存入数据
        Bundle bundle = new Bundle();
        bundle.putString(&quot;first&quot;, &quot;第一个BroadcastReceiver存入的消息&quot;);
        // 将bundle放入结果中
        setResultExtras(bundle);
        // 取消Broadcast的继续传播
        //abortBroadcast(); // ①
    }
}
</code></pre><h1 id="1008_2">1. 音乐播放器</h1>

<p><a href="#1008">返回目录</a> </p>
<p><img src="http://i.imgur.com/sJ1WkjM.jpg" alt=""></p>
<p>activity与服务中各注册了一个监听器，相互监听，因为采用了后台播放程序，所以就是退出程序，只要进程还在，音乐就可以正常播放。<br>前台</p>
<pre><code>package org.crazyit.broadcast;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
import android.widget.TextView;

public class MainActivity extends Activity implements OnClickListener
{
    // 获取界面中显示歌曲标题、作者文本框
    TextView title, author;
    // 播放/暂停、停止按钮
    ImageButton play, stop;
    ActivityReceiver activityReceiver;
    public static final String CTL_ACTION =
            &quot;org.crazyit.action.CTL_ACTION&quot;;
    public static final String UPDATE_ACTION =
            &quot;org.crazyit.action.UPDATE_ACTION&quot;;
    // 定义音乐的播放状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停
    int status = 0x11;
    String[] titleStrs = new String[] { &quot;心愿&quot;, &quot;约定&quot;, &quot;美丽新世界&quot; };
    String[] authorStrs = new String[] { &quot;未知艺术家&quot;, &quot;周蕙&quot;, &quot;伍佰&quot; };
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取程序界面界面中的两个按钮
        play = (ImageButton) this.findViewById(R.id.play);
        stop = (ImageButton) this.findViewById(R.id.stop);
        title = (TextView) findViewById(R.id.title);
        author = (TextView) findViewById(R.id.author);
        // 为两个按钮的单击事件添加监听器
        play.setOnClickListener(this);
        stop.setOnClickListener(this);
        页面注册广播
        activityReceiver = new ActivityReceiver();
        // 创建IntentFilter
        IntentFilter filter = new IntentFilter();
        // 指定BroadcastReceiver监听的Action
        filter.addAction(UPDATE_ACTION);
        // 注册BroadcastReceiver
        registerReceiver(activityReceiver, filter);
        开启服务
        Intent intent = new Intent(this, MusicService.class);
        // 启动后台Service
        startService(intent);
    }
    // 自定义的BroadcastReceiver，负责监听从Service传回来的广播
    public class ActivityReceiver extends BroadcastReceiver
    {
        @Override
        public void onReceive(Context context, Intent intent)
        {
            // 获取Intent中的update消息，update代表播放状态
            int update = intent.getIntExtra(&quot;update&quot;, -1);
            // 获取Intent中的current消息，current代表当前正在播放的歌曲
            int current = intent.getIntExtra(&quot;current&quot;, -1);
            -1代表返回的默认值
            if (current &gt;= 0)
            {
                title.setText(titleStrs[current]);
                author.setText(authorStrs[current]);
            }
            switch (update)
            {
                case 0x11:
                    play.setImageResource(R.drawable.play);
                    status = 0x11;
                    break;
                // 控制系统进入播放状态
                case 0x12:
                    // 播放状态下设置使用暂停图标
                    play.setImageResource(R.drawable.pause);
                    // 设置当前状态
                    status = 0x12;
                    break;
                // 控制系统进入暂停状态
                case 0x13:
                    // 暂停状态下设置使用播放图标
                    play.setImageResource(R.drawable.play);
                    // 设置当前状态
                    status = 0x13;
                    break;
            }
        }
    }
    @Override
    public void onClick(View source)
    {
        // 创建Intent
        Intent intent = new Intent(&quot;org.crazyit.action.CTL_ACTION&quot;);
        switch (source.getId())
        {
            // 按下播放/暂停按钮
            case R.id.play:
                intent.putExtra(&quot;control&quot;, 1);
                break;
            // 按下停止按钮
            case R.id.stop:
                intent.putExtra(&quot;control&quot;, 2);
                break;
        }
        // 发送广播，将被Service组件中的BroadcastReceiver接收到
        sendBroadcast(intent);
    }
}
</code></pre><p>后台</p>
<pre><code>package org.crazyit.broadcast;

import java.io.IOException;

import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.res.AssetFileDescriptor;
import android.content.res.AssetManager;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnCompletionListener;
import android.os.IBinder;

public class MusicService extends Service
{
    MyReceiver serviceReceiver;
    AssetManager am;
    String[] musics = new String[] { &quot;wish.mp3&quot;, &quot;promise.mp3&quot;,
            &quot;beautiful.mp3&quot; };
    MediaPlayer mPlayer;
    // 当前的状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停
    int status = 0x11;
    // 记录当前正在播放的音乐
    int current = 0;
    @Override
    public IBinder onBind(Intent intent)
    {
        return null;
    }
    @Override
    public void onCreate()
    {
        super.onCreate();
        am = getAssets();
        // 创建BroadcastReceiver
        serviceReceiver = new MyReceiver();
        // 创建IntentFilter
        IntentFilter filter = new IntentFilter();
        filter.addAction(MainActivity.CTL_ACTION);
        registerReceiver(serviceReceiver, filter);
        // 创建MediaPlayer
        mPlayer = new MediaPlayer();
        // 为MediaPlayer播放完成事件绑定监听器
        mPlayer.setOnCompletionListener(new OnCompletionListener() // ①
        {
            @Override
            public void onCompletion(MediaPlayer mp)
            {
                current++;
                if (current &gt;= 3)
                {
                    current = 0;
                }
                //发送广播通知Activity更改文本框
                Intent sendIntent = new Intent(MainActivity.UPDATE_ACTION);
                sendIntent.putExtra(&quot;current&quot;, current);
                // 发送广播，将被Activity组件中的BroadcastReceiver接收到
                sendBroadcast(sendIntent);
                // 准备并播放音乐
                prepareAndPlay(musics[current]);
            }
        });
    }
    public class MyReceiver extends BroadcastReceiver
    {
        @Override
        public void onReceive(final Context context, Intent intent)
        {
            int control = intent.getIntExtra(&quot;control&quot;, -1);
            switch (control)
            {
                // 播放或暂停
                case 1:
                    // 原来处于没有播放状态
                    if (status == 0x11)
                    {
                        // 准备并播放音乐
                        prepareAndPlay(musics[current]);
                        status = 0x12;
                    }
                    // 原来处于播放状态
                    else if (status == 0x12)
                    {
                        // 暂停
                        mPlayer.pause();
                        // 改变为暂停状态
                        status = 0x13;
                    }
                    // 原来处于暂停状态
                    else if (status == 0x13)
                    {
                        // 播放
                        mPlayer.start();
                        // 改变状态
                        status = 0x12;
                    }
                    break;
                // 停止声音
                case 2:
                    // 如果原来正在播放或暂停
                    if (status == 0x12 || status == 0x13)
                    {
                        // 停止播放
                        mPlayer.stop();
                        status = 0x11;
                    }
            }
            // 广播通知Activity更改图标、文本框
            Intent sendIntent = new Intent(MainActivity.UPDATE_ACTION);
            sendIntent.putExtra(&quot;update&quot;, status);
            sendIntent.putExtra(&quot;current&quot;, current);
            // 发送广播，将被Activity组件中的BroadcastReceiver接收到
            sendBroadcast(sendIntent);
        }
    }
    private void prepareAndPlay(String music)
    {
        try
        {
            // 打开指定音乐文件
            AssetFileDescriptor afd = am.openFd(music);
            mPlayer.reset();
            // 使用MediaPlayer加载指定的声音文件。
            mPlayer.setDataSource(afd.getFileDescriptor(),
                    afd.getStartOffset(), afd.getLength());
            // 准备声音
            mPlayer.prepare();
            // 播放
            mPlayer.start();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }
}
</code></pre><h1 id="1009">1. 接受系统广播</h1>

<p><a href="#2">返回目录</a> </p>
<p>开机自动运行服务</p>
<pre><code>开机运行的权限
&lt;!-- 授予应用程序访问系统开机事件的权限 --&gt;
    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;

&lt;!-- 定义一个BroadcastReceiver,监听系统开机广播  --&gt;
        &lt;receiver android:name=&quot;.LaunchReceiver&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;

public class LaunchReceiver extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Intent tIntent = new Intent(context
                , LaunchService.class);
        // 启动指定Service
        context.startService(tIntent);
    }
}


public class LaunchService extends Service
{
    @Override
    public IBinder onBind(Intent intent)
    {
        return null;
    }
    @Override
    public void onCreate()
    {
        // 定义1秒执行一行输出
        new Timer().schedule(new TimerTask()
        {

            @Override
            public void run()
            {
                System.out.println(&quot;-----&quot;
                        + new Date() + &quot;-----&quot;);
            }
        }, 0, 1000);
    }
}
</code></pre><p>短信提醒</p>
<pre><code>&lt;receiver android:name=&quot;SmsReceiver&quot;&gt;
            &lt;intent-filter android:priority=&quot;1000&quot;&gt;
                &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;

&lt;!-- 授予程序接收短信的权限 --&gt;
    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt;


package org.crazyit.broadcast;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.telephony.SmsMessage;
import android.widget.Toast;

import java.text.SimpleDateFormat;
import java.util.Date;

public class SmsReceiver extends BroadcastReceiver
{
    // 当接收到短信时被触发
    @Override
    public void onReceive(Context context, Intent intent)
    {
        // 如果是接收到短信
        if (intent.getAction().equals(
                &quot;android.provider.Telephony.SMS_RECEIVED&quot;))
        {
            // 取消广播（这行代码将会让系统收不到短信）
            abortBroadcast();  // ①
            StringBuilder sb = new StringBuilder();
            // 接收由SMS传过来的数据
            Bundle bundle = intent.getExtras();
            // 判断是否有数据
            if (bundle != null)
            {
                // 通过pdus可以获得接收到的所有短信消息
                Object[] pdus = (Object[]) bundle.get(&quot;pdus&quot;);
                // 构建短信对象array,并依据收到的对象长度来创建array的大小
                SmsMessage[] messages = new SmsMessage[pdus.length];
                for (int i = 0; i &lt; pdus.length; i++)
                {
                    messages[i] = SmsMessage
                            .createFromPdu((byte[]) pdus[i]);
                }
                // 将发送来的短信合并自定义信息于StringBuilder当中
                for (SmsMessage message : messages)
                {
                    sb.append(&quot;短信来源:&quot;);
                    // 获得接收短信的电话号码
                    sb.append(message.getDisplayOriginatingAddress());
                    sb.append(&quot;\n------短信内容------\n&quot;);
                    // 获得短信的内容
                    sb.append(message.getDisplayMessageBody());
                }
            }
            Toast.makeText(context, sb.toString()
                    , Toast.LENGTH_LONG).show();
        }
    }
</code></pre><p>电量提醒</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.BATTERY_STATS&quot;/&gt;

&lt;receiver android:name=&quot;.BatteryReceiver&quot;&gt;
            &lt;!-- 监听电池电量改变 --&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.BATTERY_CHANGED&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;

package org.crazyit.broadcast;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.widget.Toast;

public class BatteryReceiver extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        System.out.println(&quot;+++++++++++++++++++++++&quot;);
        Bundle bundle = intent.getExtras();
        // 获取当前电量
        int current = bundle.getInt(&quot;level&quot;);
        // 获取总电量
        int total = bundle.getInt(&quot;scale&quot;);
        // 如果当前电量小于总电量的15%
        if (current * 1.0 / total &lt; 0.15)
        {
            Toast.makeText(context, &quot;电量过低，请尽快充电！&quot;
                    , Toast.LENGTH_LONG).show();
        }
    }
}
</code></pre><h1 id="1008">1. 绑定服务并通信</h1>

<p><a href="#2">返回目录</a> </p>
<pre><code>测
</code></pre>

</body>

</html>

<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->

