<!DOCTYPE html>

<html>

<head>

<title>安卓疯狂讲义书籍</title>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<style type="text/css">

/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */

/* Author: Nicolas Hery - http://nicolashery.com */

/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */

/* Source: https://github.com/nicolahery/markdownpad-github */



/* RESET

=============================================================================*/



html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {

  margin: 0;

  padding: 0;

  border: 0;

}



/* BODY

=============================================================================*/



body {

  font-family: Helvetica, arial, freesans, clean, sans-serif;

  font-size: 14px;

  line-height: 1.6;

  color: #333;

  background-color: #fff;

  padding: 20px;

  max-width: 960px;

  margin: 0 auto;

}



body>*:first-child {

  margin-top: 0 !important;

}



body>*:last-child {

  margin-bottom: 0 !important;

}



/* BLOCKS

=============================================================================*/



p, blockquote, ul, ol, dl, table, pre {

  margin: 15px 0;

}



/* HEADERS

=============================================================================*/



h1, h2, h3, h4, h5, h6 {

  margin: 20px 0 10px;

  padding: 0;

  font-weight: bold;

  -webkit-font-smoothing: antialiased;

}



h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {

  font-size: inherit;

}



h1 {

  font-size: 28px;

  color: #000;

}



h2 {

  font-size: 24px;

  border-bottom: 1px solid #ccc;

  color: #000;

}



h3 {

  font-size: 18px;

}



h4 {

  font-size: 16px;

}



h5 {

  font-size: 14px;

}



h6 {

  color: #777;

  font-size: 14px;

}



body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {

  margin-top: 0;

  padding-top: 0;

}



a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {

  margin-top: 0;

  padding-top: 0;

}



h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {

  margin-top: 10px;

}



/* LINKS

=============================================================================*/



a {

  color: #4183C4;

  text-decoration: none;

}



a:hover {

  text-decoration: underline;

}



/* LISTS

=============================================================================*/



ul, ol {

  padding-left: 30px;

}



ul li > :first-child, 

ol li > :first-child, 

ul li ul:first-of-type, 

ol li ol:first-of-type, 

ul li ol:first-of-type, 

ol li ul:first-of-type {

  margin-top: 0px;

}



ul ul, ul ol, ol ol, ol ul {

  margin-bottom: 0;

}



dl {

  padding: 0;

}



dl dt {

  font-size: 14px;

  font-weight: bold;

  font-style: italic;

  padding: 0;

  margin: 15px 0 5px;

}



dl dt:first-child {

  padding: 0;

}



dl dt>:first-child {

  margin-top: 0px;

}



dl dt>:last-child {

  margin-bottom: 0px;

}



dl dd {

  margin: 0 0 15px;

  padding: 0 15px;

}



dl dd>:first-child {

  margin-top: 0px;

}



dl dd>:last-child {

  margin-bottom: 0px;

}



/* CODE

=============================================================================*/



pre, code, tt {

  font-size: 12px;

  font-family: Consolas, "Liberation Mono", Courier, monospace;

}



code, tt {

  margin: 0 0px;

  padding: 0px 0px;

  white-space: nowrap;

  border: 1px solid #eaeaea;

  background-color: #f8f8f8;

  border-radius: 3px;

}



pre>code {

  margin: 0;

  padding: 0;

  white-space: pre;

  border: none;

  background: transparent;

}



pre {

  background-color: #f8f8f8;

  border: 1px solid #ccc;

  font-size: 13px;

  line-height: 19px;

  overflow: auto;

  padding: 6px 10px;

  border-radius: 3px;

}



pre code, pre tt {

  background-color: transparent;

  border: none;

}



kbd {

    -moz-border-bottom-colors: none;

    -moz-border-left-colors: none;

    -moz-border-right-colors: none;

    -moz-border-top-colors: none;

    background-color: #DDDDDD;

    background-image: linear-gradient(#F1F1F1, #DDDDDD);

    background-repeat: repeat-x;

    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;

    border-image: none;

    border-radius: 2px 2px 2px 2px;

    border-style: solid;

    border-width: 1px;

    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;

    line-height: 10px;

    padding: 1px 4px;

}



/* QUOTES

=============================================================================*/



blockquote {

  border-left: 4px solid #DDD;

  padding: 0 15px;

  color: #777;

}



blockquote>:first-child {

  margin-top: 0px;

}



blockquote>:last-child {

  margin-bottom: 0px;

}



/* HORIZONTAL RULES

=============================================================================*/



hr {

  clear: both;

  margin: 15px 0;

  height: 0px;

  overflow: hidden;

  border: none;

  background: transparent;

  border-bottom: 4px solid #ddd;

  padding: 0;

}



/* TABLES

=============================================================================*/



table th {

  font-weight: bold;

}



table th, table td {

  border: 1px solid #ccc;

  padding: 6px 13px;

}



table tr {

  border-top: 1px solid #ccc;

  background-color: #fff;

}



table tr:nth-child(2n) {

  background-color: #f8f8f8;

}



/* IMAGES

=============================================================================*/



img {

  max-width: 100%

}

</style>

<style type="text/css">

.highlight  { background: #ffffff; }

.highlight .c { color: #999988; font-style: italic } /* Comment */

.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */

.highlight .k { font-weight: bold } /* Keyword */

.highlight .o { font-weight: bold } /* Operator */

.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */

.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */

.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */

.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */

.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */

.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */

.highlight .ge { font-style: italic } /* Generic.Emph */

.highlight .gr { color: #aa0000 } /* Generic.Error */

.highlight .gh { color: #999999 } /* Generic.Heading */

.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */

.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */

.highlight .go { color: #888888 } /* Generic.Output */

.highlight .gp { color: #555555 } /* Generic.Prompt */

.highlight .gs { font-weight: bold } /* Generic.Strong */

.highlight .gu { color: #aaaaaa } /* Generic.Subheading */

.highlight .gt { color: #aa0000 } /* Generic.Traceback */

.highlight .kc { font-weight: bold } /* Keyword.Constant */

.highlight .kd { font-weight: bold } /* Keyword.Declaration */

.highlight .kp { font-weight: bold } /* Keyword.Pseudo */

.highlight .kr { font-weight: bold } /* Keyword.Reserved */

.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */

.highlight .m { color: #009999 } /* Literal.Number */

.highlight .s { color: #d14 } /* Literal.String */

.highlight .na { color: #008080 } /* Name.Attribute */

.highlight .nb { color: #0086B3 } /* Name.Builtin */

.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */

.highlight .no { color: #008080 } /* Name.Constant */

.highlight .ni { color: #800080 } /* Name.Entity */

.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */

.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */

.highlight .nn { color: #555555 } /* Name.Namespace */

.highlight .nt { color: #000080 } /* Name.Tag */

.highlight .nv { color: #008080 } /* Name.Variable */

.highlight .ow { font-weight: bold } /* Operator.Word */

.highlight .w { color: #bbbbbb } /* Text.Whitespace */

.highlight .mf { color: #009999 } /* Literal.Number.Float */

.highlight .mh { color: #009999 } /* Literal.Number.Hex */

.highlight .mi { color: #009999 } /* Literal.Number.Integer */

.highlight .mo { color: #009999 } /* Literal.Number.Oct */

.highlight .sb { color: #d14 } /* Literal.String.Backtick */

.highlight .sc { color: #d14 } /* Literal.String.Char */

.highlight .sd { color: #d14 } /* Literal.String.Doc */

.highlight .s2 { color: #d14 } /* Literal.String.Double */

.highlight .se { color: #d14 } /* Literal.String.Escape */

.highlight .sh { color: #d14 } /* Literal.String.Heredoc */

.highlight .si { color: #d14 } /* Literal.String.Interpol */

.highlight .sx { color: #d14 } /* Literal.String.Other */

.highlight .sr { color: #009926 } /* Literal.String.Regex */

.highlight .s1 { color: #d14 } /* Literal.String.Single */

.highlight .ss { color: #990073 } /* Literal.String.Symbol */

.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */

.highlight .vc { color: #008080 } /* Name.Variable.Class */

.highlight .vg { color: #008080 } /* Name.Variable.Global */

.highlight .vi { color: #008080 } /* Name.Variable.Instance */

.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */

.pl-c {

    color: #969896;

}



.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {

    color: #0086b3;

}



.pl-e,.pl-en {

    color: #795da3;

}



.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {

    color: #333;

}



.pl-ent {

    color: #63a35c;

}



.pl-k,.pl-s,.pl-st {

    color: #a71d5d;

}



.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {

    color: #df5000;

}



.pl-id {

    color: #b52a1d;

}



.pl-ii {

    background-color: #b52a1d;

    color: #f8f8f8;

}



.pl-sr .pl-cce {

    color: #63a35c;

    font-weight: bold;

}



.pl-ml {

    color: #693a17;

}



.pl-mh,.pl-mh .pl-en,.pl-ms {

    color: #1d3e81;

    font-weight: bold;

}



.pl-mq {

    color: #008080;

}



.pl-mi {

    color: #333;

    font-style: italic;

}



.pl-mb {

    color: #333;

    font-weight: bold;

}



.pl-md,.pl-mdhf {

    background-color: #ffecec;

    color: #bd2c00;

}



.pl-mdht,.pl-mi1 {

    background-color: #eaffea;

    color: #55a532;

}



.pl-mdr {

    color: #795da3;

    font-weight: bold;

}



.pl-mo {

    color: #1d3e81;

}

.task-list {

padding-left:10px;

margin-bottom:0;

}



.task-list li {

    margin-left: 20px;

}



.task-list-item {

list-style-type:none;

padding-left:10px;

}



.task-list-item label {

font-weight:400;

}



.task-list-item.enabled label {

cursor:pointer;

}



.task-list-item+.task-list-item {

margin-top:3px;

}



.task-list-item-checkbox {

display:inline-block;

margin-left:-20px;

margin-right:3px;

vertical-align:1px;

}

</style>

</head>

<body>

<h1 id="2017-08-17">2017 08 17</h1>
<blockquote>
<p> <a href="http://pan.baidu.com/disk/home?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;#list/vmode=list&amp;path=%2F%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%B9%2F%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%2FMarkDown%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3" title="查看">文档地址</a>→<a href="http://pan.baidu.com/disk/home?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;#list/vmode=list&amp;path=%2F%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%B9%2F%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%2FAndBaseDemo%E6%A1%86%E6%9E%B6" title="查看">源文件相关</a>→<a href="https://tanyinqing.github.io/">首页</a></p>
</blockquote>
<h1 id="1">目录1</h1> 

<ul>
<li><h3 id="1-">1应用和环境→</h3>
</li><li><h3 id="2-">2界面编程→</h3>
</li><li><h3 id="3-0301-0302-0303-handler-0304-0305-">3事件处理→<a href="#0301">基于监听的事件处理</a>→<a href="#0302">基于回调的事件处理</a>→<a href="#0303">相应系统设置的事件和响应系统设置的更改</a>→<a href="#0304">Handler消息传递机制</a>→<a href="#0305">异步任务</a></h3>
</li><li><h3 id="4activity-fragment-activity-0401-fragment-0402-">4Activity与Fragment→<a href="#0401">Activity</a>→<a href="#0402">Fragment</a></h3>
</li><li><h3 id="5-">5意图和意图过滤器通信→</h3>
</li><li><h3 id="6-">6资源→</h3>
</li><li><h3 id="7-">7图形与图像处理→</h3>
</li></ul>
<h1 id="2">目录2</h1>  

<ul>
<li><h3 id="8-io-">8数据存储与io→</h3>
</li><li><h3 id="9contentprovider-contentprovider-0901-">9ContentProvider实现数据共享→<a href="#0901">ContentProvider</a></h3>
</li><li><h3 id="10-1001-intentservice-1002-1003-1004-1005-1006-1007-1008-1009-">10 服务与广播→<a href="#1001">绑定服务并通信</a>→<a href="#1002">IntentService</a>→<a href="#1003">电话管理器</a>→<a href="#1004">短信管理器</a>→<a href="#1005">音频管理器</a>→<a href="#1006">振动管理器</a>→<a href="#1007">手机闹钟服务</a>→<a href="#1008">接受广播服务</a>→<a href="#1009">接受系统广播</a></h3>
</li></ul>
<ul>
<li><h3 id="11-">11多媒体应用开发→</h3>
</li><li><h3 id="12-opengl-3d-">12 OpenGL与3D开发→</h3>
</li><li><h3 id="13-">13 网络应用→</h3>
</li><li><h3 id="14-">14 管理手机桌面→</h3>
</li></ul>
<h1 id="3">目录3</h1> 

<ul>
<li><h3 id="15-">15 传感器应用开发→</h3>
</li><li><h3 id="16-gps-">16 GPS应用开发→</h3>
</li><li><h3 id="17-map-">17 高德map服务→</h3>
</li><li><h3 id="18-">18 合金弹头→</h3>
</li><li><h3 id="19-">19 电子拍卖系统→</h3>
</li></ul>
<h1 id="-">参考文档</h1>
<p> <a href="http://pan.baidu.com/disk/home?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;#list/vmode=list&amp;path=%2F%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%B9%2F%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97" title="查看">百度项目地址</a></p>
<h1 id="0901">ContentProvider 数据共享标准</h1>

<p><a href="#2">返回目录</a><br>需要2个应用，一个是ContentProvider，一个是ContentResolver。一个应用调用其他应用的信息<br>ContentProvider是安卓不同程序之间数据交换的标准接口</p>
<p><a href="#0901_1">基本定义和应用方法</a><br><a href="#0901_2">创建一个生词本</a><br><a href="#0901_3">操作系统的ContentProvider管理联系人</a><br><a href="#0901_4">ContentProvider管理多媒体内容</a><br><a href="#0901_5">监听ContentProvider的数据改变</a></p>
<h1 id="0901_1">ContentProvider 数据共享标准</h1>

<p><a href="#0901">返回目录</a><br><img src="http://i.imgur.com/BcpN2XX.jpg" alt=""></p>
<p>定义一个应用ContentProvider的子类</p>
<pre><code>&lt;!-- 注册一个ContentProvider  android:authorities这个是地址--&gt;
        &lt;provider
            android:exported=&quot;true&quot;
            android:name=&quot;.FirstProvider&quot;
            android:authorities=&quot;org.crazyit.providers.firstprovider&quot;&gt;
        &lt;/provider&gt;


package org.crazyit.content;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;

public class FirstProvider extends ContentProvider
{
    // 第一次创建该ContentProvider时调用该方法
    @Override
    public boolean onCreate()
    {
        System.out.println(&quot;===onCreate方法被调用===&quot;);
        return true;
    }
    // 该方法的返回值代表了该ContentProvider所提供数据的MIME类型
    @Override
    public String getType(Uri uri)
    {
        return null;
    }
    // 实现查询方法，该方法应该返回查询得到的Cursor
    @Override
    public Cursor query(Uri uri, String[] projection, String where,
                        String[] whereArgs, String sortOrder)
    {
        System.out.println(uri + &quot;===query方法被调用===&quot;);
        System.out.println(&quot;where参数为：&quot; + where);
        return null;
    }
    // 实现插入的方法，该方法应该返回新插入的记录的Uri
    @Override
    public Uri insert(Uri uri, ContentValues values)
    {
        System.out.println(uri + &quot;===insert方法被调用===&quot;);
        System.out.println(&quot;values参数为：&quot; + values);
        return null;
    }
    // 实现删除方法，该方法应该返回被更新的记录条数
    @Override
    public int update(Uri uri, ContentValues values, String where,
                      String[] whereArgs)
    {
        System.out.println(uri + &quot;===update方法被调用===&quot;);
        System.out.println(&quot;where参数为：&quot;
                + where + &quot;,values参数为：&quot; + values);
        return 0;
    }
    // 实现删除方法，该方法应该返回被删除的记录条数
    @Override
    public int delete(Uri uri, String where, String[] whereArgs)
    {
        System.out.println(uri + &quot;===delete方法被调用===&quot;);
        System.out.println(&quot;where参数为：&quot; + where);
        return 0;
    }
}
</code></pre><p>调用前一个ContentProvider的子类的方法，实现增删改查的操作</p>
<pre><code>package org.crazyit.resolver;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;


public class MainActivity extends Activity
{
    ContentResolver contentResolver;
    Uri uri = Uri.parse(&quot;content://org.crazyit.providers.firstprovider/&quot;);
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取系统的ContentResolver对象
        contentResolver = getContentResolver();
    }
    public void query(View source)
    {
        // 调用ContentResolver的query()方法
        // 实际返回的是该Uri对应的ContentProvider的query()的返回值
        Cursor c = contentResolver.query(uri, null
            , &quot;query_where&quot;, null, null);
        Toast.makeText(this, &quot;远程ContentProvide返回的Cursor为：&quot; + c,
                Toast.LENGTH_SHORT).show();
    }
    public void insert(View source)
    {
        ContentValues values = new ContentValues();
        values.put(&quot;name&quot;, &quot;fkjava&quot;);
        // 调用ContentResolver的insert()方法。
        // 实际返回的是该Uri对应的ContentProvider的insert()的返回值
        Uri newUri = contentResolver.insert(uri, values);
        Toast.makeText(this, &quot;远程ContentProvide新插入记录的Uri为：&quot;
                + newUri, Toast.LENGTH_SHORT).show();
    }
    public void update(View source)
    {
        ContentValues values = new ContentValues();
        values.put(&quot;name&quot;, &quot;fkjava&quot;);
        // 调用ContentResolver的update()方法。
        // 实际返回的是该Uri对应的ContentProvider的update()的返回值
        int count = contentResolver.update(uri, values
                , &quot;update_where&quot;, null);
        Toast.makeText(this, &quot;远程ContentProvide更新记录数为：&quot;
                + count, Toast.LENGTH_SHORT).show();
    }
    public void delete(View source)
    {
        // 调用ContentResolver的delete()方法
        // 实际返回的是该Uri对应的ContentProvider的delete()的返回值
        int count = contentResolver.delete(uri
                , &quot;delete_where&quot;, null);
        Toast.makeText(this, &quot;远程ContentProvide删除记录数为：&quot;
                + count, Toast.LENGTH_SHORT).show();
    }
}
</code></pre><h1 id="0901_2">创建一个生词本</h1>

<p><a href="#0901">返回目录</a> </p>
<p>实际上就是一个应用对另一个应用的数据进行增删改查的操作<br><img src="http://i.imgur.com/r8PCrcf.jpg" alt=""><br><img src="http://i.imgur.com/0uKGLjM.jpg" alt=""></p>
<p>分为两个应用，一个是能被操纵的应用Provider，一个是执行操作的应用ContentResolver</p>
<p><a href="#0901_2_1">被操纵的应用Provide</a><br><a href="#0901_2_2">执行操作的应用ContentResolver</a> </p>
<h1 id="0901_2_1">被操纵的应用Provide</h1>

<p><a href="#0901_2">返回目录</a><br>定义2个uri和三个数据列的工具类</p>
<pre><code>package org.crazyit.content;

import android.net.Uri;
import android.provider.BaseColumns;

public final class Words
{
    // 定义该ContentProvider的Authorities
    public static final String AUTHORITY
            = &quot;org.crazyit.providers.dictprovider&quot;;
    // 定义一个静态内部类，定义该ContentProvider所包含的数据列的列名
    public static final class Word implements BaseColumns
    {
        // 定义Content所允许操作的三个数据列
        public final static String _ID = &quot;_id&quot;;
        public final static String WORD = &quot;word&quot;;
        public final static String DETAIL = &quot;detail&quot;;
        // 定义该Content提供服务的两个Uri
        public final static Uri DICT_CONTENT_URI = Uri
            .parse(&quot;content://&quot; + AUTHORITY + &quot;/words&quot;);
        public final static Uri WORD_CONTENT_URI = Uri
            .parse(&quot;content://&quot;    + AUTHORITY + &quot;/word&quot;);
    }
}
</code></pre><p>定义数据库操作类  使用代码建立数据库</p>
<pre><code>package org.crazyit.content;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class MyDatabaseHelper extends SQLiteOpenHelper
{
    final String CREATE_TABLE_SQL =
            &quot;create table dict(_id integer primary &quot; +
                    &quot;key autoincrement , word , detail)&quot;;
    public MyDatabaseHelper(Context context, String name, int version)
    {
        super(context, name, null, version);
    }
    @Override
    public void onCreate(SQLiteDatabase db)
    {
        // 第一次使用数据库时自动建表
        db.execSQL(CREATE_TABLE_SQL);
    }
    @Override
    public void onUpgrade(SQLiteDatabase db
            , int oldVersion, int newVersion)
    {
        System.out.println(&quot;--------onUpdate Called--------&quot;
                + oldVersion + &quot;---&gt;&quot; + newVersion);
    }
}
</code></pre><p>定义DictProvider，对外提供接口和注册</p>
<pre><code>&lt;!-- 注册一个ContentProvider --&gt;
        &lt;provider android:name=&quot;.DictProvider&quot;
                  android:authorities=&quot;org.crazyit.providers.dictprovider&quot;
                  android:exported=&quot;true&quot;/&gt;

package org.crazyit.content;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;

public class DictProvider extends ContentProvider
{
    private static UriMatcher matcher
            = new UriMatcher(UriMatcher.NO_MATCH);
    private static final int WORDS = 1;
    private static final int WORD = 2;
    private MyDatabaseHelper dbOpenHelper;
    static
    {
        // 为UriMatcher注册两个Uri 它是Uri的管理器
        matcher.addURI(Words.AUTHORITY, &quot;words&quot;, WORDS);
        matcher.addURI(Words.AUTHORITY, &quot;word/#&quot;, WORD);
    }
    // 第一次调用该DictProvider时，系统先创建DictProvider对象，并回调该方法
    @Override
    public boolean onCreate()
    {
        dbOpenHelper = new MyDatabaseHelper(this.getContext(),
                &quot;myDict.db3&quot;, 1);
        return true;
    }
    // 返回指定Uri参数对应的数据的MIME类型
    @Override
    public String getType(Uri uri)
    {
        switch (matcher.match(uri))
        {
            // 如果操作的数据是多项记录
            case WORDS:
                return &quot;vnd.android.cursor.dir/org.crazyit.dict&quot;;
            // 如果操作的数据是单项记录
            case WORD:
                return &quot;vnd.android.cursor.item/org.crazyit.dict&quot;;
            default:
                throw new IllegalArgumentException(&quot;未知Uri:&quot; + uri);
        }
    }
    // 查询数据的方法  一个代表操作全部数据项 一个代表操作部分数据项
    @Override
    public Cursor query(Uri uri, String[] projection, String where,
                        String[] whereArgs, String sortOrder)
    {
        SQLiteDatabase db = dbOpenHelper.getReadableDatabase();
        switch (matcher.match(uri))
        {
            // 如果Uri参数代表操作全部数据项
            case WORDS:
                // 执行查询
                return db.query(&quot;dict&quot;, projection, where,
                        whereArgs, null, null, sortOrder);
            // 如果Uri参数代表操作指定数据项
            case WORD:
                // 解析出想查询的记录ID
                long id = ContentUris.parseId(uri);
                String whereClause = Words.Word._ID + &quot;=&quot; + id;
                // 如果原来的where子句存在，拼接where子句
                if (where != null &amp;&amp; !&quot;&quot;.equals(where))
                {
                    whereClause = whereClause + &quot; and &quot; + where;
                }
                return db.query(&quot;dict&quot;, projection, whereClause, whereArgs,
                        null, null, sortOrder);
            default:
                throw new IllegalArgumentException(&quot;未知Uri:&quot; + uri);
        }
    }
    // 插入数据方法
    @Override
    public Uri insert(Uri uri, ContentValues values)
    {
        // 获得数据库实例
        SQLiteDatabase db = dbOpenHelper.getReadableDatabase();
        switch (matcher.match(uri))
        {
            // 如果Uri参数代表操作全部数据项
            case WORDS:
                // 插入数据，返回插入记录的ID
                long rowId = db.insert(&quot;dict&quot;, Words.Word._ID, values);
                // 如果插入成功返回uri
                if (rowId &gt; 0)
                {
                    // 在已有的 Uri的后面追加ID
                    Uri wordUri = ContentUris.withAppendedId(uri, rowId);
                    // 通知数据已经改变
                    getContext().getContentResolver()
                            .notifyChange(wordUri, null);
                    return wordUri;
                }
                break;
            default :
                throw new IllegalArgumentException(&quot;未知Uri:&quot; + uri);
        }
        return null;
    }
    // 修改数据的方法
    @Override
    public int update(Uri uri, ContentValues values, String where,
                      String[] whereArgs)
    {
        SQLiteDatabase db = dbOpenHelper.getWritableDatabase();
        // 记录所修改的记录数
        int num = 0;
        switch (matcher.match(uri))
        {
            // 如果Uri参数代表操作全部数据项
            case WORDS:
                num = db.update(&quot;dict&quot;, values, where, whereArgs);
                break;
            // 如果Uri参数代表操作指定数据项
            case WORD:
                // 解析出想修改的记录ID
                long id = ContentUris.parseId(uri);
                String whereClause = Words.Word._ID + &quot;=&quot; + id;
                // 如果原来的where子句存在，拼接where子句
                if (where != null &amp;&amp; !where.equals(&quot;&quot;))
                {
                    whereClause = whereClause + &quot; and &quot; + where;
                }
                num = db.update(&quot;dict&quot;, values, whereClause, whereArgs);
                break;
            default:
                throw new IllegalArgumentException(&quot;未知Uri:&quot; + uri);
        }
        // 通知数据已经改变
        getContext().getContentResolver().notifyChange(uri, null);
        return num;
    }
    // 删除数据的方法
    @Override
    public int delete(Uri uri, String where, String[] whereArgs)
    {
        SQLiteDatabase db = dbOpenHelper.getReadableDatabase();
        // 记录所删除的记录数
        int num = 0;
        // 对uri进行匹配
        switch (matcher.match(uri))
        {
            // 如果Uri参数代表操作全部数据项
            case WORDS:
                num = db.delete(&quot;dict&quot;, where, whereArgs);
                break;
            // 如果Uri参数代表操作指定数据项
            case WORD:
                // 解析出所需要删除的记录ID
                long id = ContentUris.parseId(uri);
                String whereClause = Words.Word._ID + &quot;=&quot; + id;
                // 如果原来的where子句存在，拼接where子句
                if (where != null &amp;&amp; !where.equals(&quot;&quot;))
                {
                    whereClause = whereClause + &quot; and &quot; + where;
                }
                num = db.delete(&quot;dict&quot;, whereClause, whereArgs);
                break;
            default:
                throw new IllegalArgumentException(&quot;未知Uri:&quot; + uri);
        }
        // 通知数据已经改变
        getContext().getContentResolver().notifyChange(uri, null);
        return num;
    }
}
</code></pre><p>主页面应用数据库提取数据  应用SQL语句 查询时应用了模糊查询</p>
<pre><code>package org.crazyit.content;

import android.app.Activity;
import android.content.Intent;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;


public class MainActivity extends Activity
{
    MyDatabaseHelper dbHelper;
    Button insert = null;
    Button search = null;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 创建MyDatabaseHelper对象，指定数据库版本为1，此处使用相对路径即可
        // 数据库文件自动会保存在程序的数据文件夹的databases目录下
        dbHelper = new MyDatabaseHelper(this, &quot;myDict.db3&quot;, 1);
        insert = (Button) findViewById(R.id.insert);
        search = (Button) findViewById(R.id.search);
        insert.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 获取用户输入
                String word = ((EditText) findViewById(R.id.word))
                        .getText().toString();
                String detail = ((EditText) findViewById(R.id.detail))
                        .getText().toString();
                // 插入生词记录
                insertData(dbHelper.getReadableDatabase(), word, detail);
                // 显示提示信息
                Toast.makeText(MainActivity.this, &quot;添加生词成功！&quot;
                        , Toast.LENGTH_LONG).show();
            }
        });
        search.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 获取用户输入
                String key = ((EditText) findViewById(R.id.key)).getText()
                        .toString();
                // 执行查询
                Cursor cursor = dbHelper.getReadableDatabase().rawQuery(
                        &quot;select * from dict where word like ? or detail like ?&quot;,
                        new String[] { &quot;%&quot; + key + &quot;%&quot;, &quot;%&quot; + key + &quot;%&quot; });
                // 创建一个Bundle对象
                Bundle data = new Bundle();
                data.putSerializable(&quot;data&quot;, converCursorToList(cursor));
                // 创建一个Intent
                Intent intent = new Intent(MainActivity.this
                        , ResultActivity.class);
                intent.putExtras(data);
                // 启动Activity
                startActivity(intent);
            }
        });
    }
    //把cursor对应的数据收集成链表
    protected ArrayList&lt;Map&lt;String, String&gt;&gt;
    converCursorToList(Cursor cursor)
    {
        ArrayList&lt;Map&lt;String, String&gt;&gt; result =
                new ArrayList&lt;Map&lt;String, String&gt;&gt;();
        // 遍历Cursor结果集
        while (cursor.moveToNext())
        {
            // 将结果集中的数据存入ArrayList中
            Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
            // 取出查询记录中第2列、第3列的值
            map.put(&quot;word&quot;, cursor.getString(1));
            map.put(&quot;detail&quot;, cursor.getString(2));
            result.add(map);
        }
        return result;
    }
    private void insertData(SQLiteDatabase db, String word
            , String detail)
    {
        // 执行插入语句
        db.execSQL(&quot;insert into dict values(null , ? , ?)&quot;
                , new String[] {word, detail });
    }
    @Override
    public void onDestroy()
    {
        super.onDestroy();
        // 退出程序时关闭MyDatabaseHelper里的SQLiteDatabase
        if (dbHelper != null)
        {
            dbHelper.close();
        }
    }
}
</code></pre><p>把数据库数据提取成列表</p>
<pre><code>package org.crazyit.content;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.widget.ListView;
import android.widget.SimpleAdapter;

import java.util.List;
import java.util.Map;

public class ResultActivity extends Activity
{
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.popup);
        ListView listView = (ListView) findViewById(R.id.show);
        Intent intent = getIntent();
        // 获取该intent所携带的数据
        Bundle data = intent.getExtras();
        // 从Bundle数据包中取出数据
        @SuppressWarnings(&quot;unchecked&quot;)
        List&lt;Map&lt;String, String&gt;&gt; list = (List&lt;Map&lt;String, String&gt;&gt;)
                data.getSerializable(&quot;data&quot;);
        // 将List封装成SimpleAdapter
        SimpleAdapter adapter = new SimpleAdapter(ResultActivity.this
                , list,
                R.layout.line, new String[] { &quot;word&quot;, &quot;detail&quot; }
                , new int[] {R.id.word, R.id.detail });
        // 填充ListView
        listView.setAdapter(adapter);
    }
}
</code></pre><h1 id="0901_2_2">执行操作的应用ContentResolver</h1>

<p><a href="#0901_2">返回目录</a> </p>
<p>应用接口进行数据查询</p>
<pre><code>package org.crazyit.resolver;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Intent;
import android.database.Cursor;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import org.crazyit.content.Words;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;


public class MainActivity extends Activity
{
    ContentResolver contentResolver;
    Button insert = null;
    Button search = null;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取系统的ContentResolver对象
        contentResolver = getContentResolver();
        insert = (Button) findViewById(R.id.insert);
        search = (Button) findViewById(R.id.search);
        // 为insert按钮的单击事件绑定事件监听器
        insert.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 获取用户输入
                String word = ((EditText) findViewById(R.id.word))
                    .getText().toString();
                String detail = ((EditText) findViewById(R.id.detail))
                    .getText().toString();
                // 插入生词记录
                ContentValues values = new ContentValues();
                values.put(Words.Word.WORD, word);
                values.put(Words.Word.DETAIL, detail);
                contentResolver.insert(
                    Words.Word.DICT_CONTENT_URI, values);
                // 显示提示信息
                Toast.makeText(MainActivity.this, &quot;添加生词成功！&quot;
                    , Toast.LENGTH_SHORT).show();
            }
        });
        // 为search按钮的单击事件绑定事件监听器
        search.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 获取用户输入
                String key = ((EditText) findViewById(R.id.key))
                    .getText().toString();
                // 执行查询
                Cursor cursor = contentResolver.query(
                    Words.Word.DICT_CONTENT_URI, null,
                    &quot;word like ? or detail like ?&quot;, new String[] {
                    &quot;%&quot; + key + &quot;%&quot;, &quot;%&quot; + key + &quot;%&quot; }, null);
                // 创建一个Bundle对象
                Bundle data = new Bundle();
                data.putSerializable(&quot;data&quot;, converCursorToList(cursor));
                // 创建一个Intent
                Intent intent = new Intent(MainActivity.this,
                    ResultActivity.class);
                intent.putExtras(data);
                // 启动Activity
                startActivity(intent);
            }
        });
    }
    private ArrayList&lt;Map&lt;String, String&gt;&gt; converCursorToList(Cursor cursor)
    {
        ArrayList&lt;Map&lt;String, String&gt;&gt; result = new ArrayList&lt;&gt;();
        // 遍历Cursor结果集
        while (cursor.moveToNext())
        {
            // 将结果集中的数据存入ArrayList中
            Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
            // 取出查询记录中第2列、第3列的值
            map.put(Words.Word.WORD, cursor.getString(1));
            map.put(Words.Word.DETAIL, cursor.getString(2));
            result.add(map);
        }
        return result;
    }
}
</code></pre><h1 id="0901_3">操作系统的ContentProvider管理联系人</h1>

<p><a href="#0901">返回目录</a> </p>
<p><img src="http://i.imgur.com/xHk0e6J.jpg" alt=""></p>
<p><img src="http://i.imgur.com/NEbqooD.jpg" alt=""></p>
<p>读写联系人的权限<br>向操作系统中加入联系人的信息</p>
<pre><code class="lang-.">&lt;!-- 授予读联系人ContentProvider的权限 --&gt;
    &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;
    &lt;!-- 授予写联系人ContentProvider的权限 --&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;

// 为add按钮的单击事件绑定监听器
        add.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                // 获取程序界面中的三个文本框的内容
                String name = ((EditText) findViewById(R.id.name))
                    .getText().toString();
                String phone = ((EditText) findViewById(R.id.phone))
                    .getText().toString();
                String email = ((EditText) findViewById(R.id.email))
                    .getText().toString();
                // 创建一个空的ContentValues
                ContentValues values = new ContentValues();
                // 向RawContacts.CONTENT_URI执行一个空值插入
                // 目的是获取系统返回的rawContactId
                Uri rawContactUri = getContentResolver().insert(
                    ContactsContract.RawContacts.CONTENT_URI, values);
                //用于从指定的Uri中解析出所包含的ID值
                long rawContactId = ContentUris.parseId(rawContactUri);

                //添加联系人名字 分别定义行号和列号    
                values.clear();
                values.put(Data.RAW_CONTACT_ID, rawContactId);
                // 设置内容类型
                values.put(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);
                // 设置联系人名字
                values.put(StructuredName.GIVEN_NAME, name);
                // 向联系人URI添加联系人名字
                getContentResolver().insert(android.provider.ContactsContract
                    .Data.CONTENT_URI, values);

            //添加电话号码 分别定义行号和列号
                values.clear();
                values.put(Data.RAW_CONTACT_ID, rawContactId);
                values.put(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE);
                // 设置联系人的电话号码
                values.put(Phone.NUMBER, phone);
                // 设置电话类型
                values.put(Phone.TYPE, Phone.TYPE_MOBILE);
                // 向联系人电话号码URI添加电话号码
                getContentResolver().insert(android.provider.ContactsContract
                    .Data.CONTENT_URI, values);

                //添加邮箱信息 分别定义行号和列号
                values.clear();
                values.put(Data.RAW_CONTACT_ID, rawContactId);//行号
                values.put(Data.MIMETYPE, Email.CONTENT_ITEM_TYPE);
                // 设置联系人的E-mail地址
                values.put(Email.DATA, email);
                // 设置该电子邮件的类型
                values.put(Email.TYPE, Email.TYPE_WORK);
                // 向联系人E-mail URI添加E-mail数据
                getContentResolver().insert(android.provider.ContactsContract
                    .Data.CONTENT_URI, values);
                Toast.makeText(MainActivity.this, &quot;联系人数据添加成功&quot;,
                    Toast.LENGTH_SHORT).show();
            }
        });
</code></pre>
<p>从操作系统中读取联系人的信息</p>
<pre><code>// 获取系统界面中查找、添加两个按钮
        search = (Button) findViewById(R.id.search);
        add = (Button) findViewById(R.id.add);
        search.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 定义两个List来封装系统的联系人信息、指定联系人的电话号码、Email等详情
                final ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
                final ArrayList&lt;ArrayList&lt;String&gt;&gt; details = new ArrayList&lt;&gt;();
                // 使用ContentResolver查找联系人数据 Contact 接触
                Cursor cursor = getContentResolver().query(
                    ContactsContract.Contacts.CONTENT_URI, null, null,
                    null, null);
                // 遍历查询结果，获取系统中所有联系人
                while (cursor.moveToNext())
                {
                    // 获取联系人ID
                    String contactId = cursor.getString(cursor
                        .getColumnIndex(ContactsContract.Contacts._ID));
                    // 获取联系人的名字
                    String name = cursor.getString(cursor.getColumnIndex(
                        ContactsContract.Contacts.DISPLAY_NAME));
                    names.add(name);  
                    // 使用ContentResolver查找联系人的电话号码
                    Cursor phones = getContentResolver().query(
                        ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
                        null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID
                        + &quot; = &quot; + contactId, null, null);
                    ArrayList&lt;String&gt; detail = new ArrayList&lt;&gt;();
                    // 遍历查询结果，获取该联系人的多个电话号码
                    while (phones.moveToNext())
                    {
                        // 获取查询结果中电话号码列中数据
                        String phoneNumber = phones.getString(phones
                            .getColumnIndex(ContactsContract
                                    .CommonDataKinds.Phone.NUMBER));
                        detail.add(&quot;电话号码：&quot; + phoneNumber);
                    }
                    phones.close();
                    // 使用ContentResolver查找联系人的E-mail地址
                    Cursor emails = getContentResolver().query(
                        ContactsContract.CommonDataKinds.Email.CONTENT_URI,
                        null, ContactsContract.CommonDataKinds.Email
                        .CONTACT_ID + &quot; = &quot; + contactId, null, null);
                    // 遍历查询结果，获取该联系人的多个E-mail地址
                    while (emails.moveToNext())
                    {
                        // 获取查询结果中E-mail地址列中数据
                        String emailAddress = emails.getString(emails
                            .getColumnIndex(ContactsContract
                                    .CommonDataKinds.Email.DATA));
                        detail.add(&quot;邮件地址：&quot; + emailAddress);
                    }
                    emails.close();
                    details.add(detail);
                }
                cursor.close();
                // 加载result.xml界面布局代表的视图
                View resultDialog = getLayoutInflater().inflate(
                    R.layout.result, null);
                // 获取resultDialog中ID为list的ExpandableListView
                ExpandableListView list = (ExpandableListView) resultDialog
                    .findViewById(R.id.list);
                // 创建一个ExpandableListAdapter对象
                ExpandableListAdapter adapter =
                    new BaseExpandableListAdapter()
                    {
                        // 获取指定组位置、指定子列表项处的子列表项数据
                        @Override
                        public Object getChild(int groupPosition,
                                               int childPosition)
                        {
                            return details.get(groupPosition).get(
                                    childPosition);
                        }
                        @Override
                        public long getChildId(int groupPosition,
                                               int childPosition)
                        {
                            return childPosition;
                        }
                        @Override
                        public int getChildrenCount(int groupPosition)
                        {
                            return details.get(groupPosition).size();
                        }
                        private TextView getTextView()
                        {
                            AbsListView.LayoutParams lp = new AbsListView
                                .LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT
                                , 64);
                            TextView textView = new TextView(
                                MainActivity.this);
                            textView.setLayoutParams(lp);
                            textView.setGravity(Gravity.CENTER_VERTICAL
                                | Gravity.LEFT);
                            textView.setPadding(36, 0, 0, 0);
                            textView.setTextSize(20);
                            return textView;
                        }
                        // 该方法决定每个子选项的外观
                        @Override
                        public View getChildView(int groupPosition,
                            int childPosition, boolean isLastChild,
                            View convertView, ViewGroup parent)
                        {
                            TextView textView = getTextView();
                            textView.setText(getChild(groupPosition,
                                childPosition).toString());
                            return textView;
                        }
                        // 获取指定组位置处的组数据
                        @Override
                        public Object getGroup(int groupPosition)
                        {
                            return names.get(groupPosition);
                        }
                        @Override
                        public int getGroupCount()
                        {
                            return names.size();
                        }
                        @Override
                        public long getGroupId(int groupPosition)
                        {
                            return groupPosition;
                        }
                        // 该方法决定每个组选项的外观
                        @Override
                        public View getGroupView(int groupPosition,
                            boolean isExpanded, View convertView,
                            ViewGroup parent)
                        {
                            TextView textView = getTextView();
                            textView.setText(getGroup(groupPosition)
                                .toString());
                            return textView;
                        }
                        @Override
                        public boolean isChildSelectable(int groupPosition,
                            int childPosition)
                        {
                            return true;
                        }
                        @Override
                        public boolean hasStableIds()
                        {
                            return true;
                        }
                    };
                // 为ExpandableListView设置Adapter对象
                list.setAdapter(adapter);
                // 使用对话框来显示查询结果
                new AlertDialog.Builder(MainActivity.this)
                    .setView(resultDialog).setPositiveButton(&quot;确定&quot;, null)
                    .show();
            }
        });
</code></pre><h1 id="0901_4">操作系统的ContentProvider管理联系人</h1>

<p><a href="#0901">返回目录</a><br><img src="http://i.imgur.com/eoEQTlN.jpg" alt=""><br><img src="http://i.imgur.com/e42PmTw.jpg" alt=""><br>添加 就是将程序中指定图片添加到多媒体的数据中</p>
<pre><code>package org.crazyit.content;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.ContentValues;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.provider.MediaStore.Images.Media;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.SimpleAdapter;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


public class MainActivity extends Activity
{
    Button add;
    Button view;
    ListView show;
    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
    ArrayList&lt;String&gt; descs = new ArrayList&lt;&gt;();
    ArrayList&lt;String&gt; fileNames = new ArrayList&lt;&gt;();
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        add = (Button) findViewById(R.id.add);
        view = (Button) findViewById(R.id.view);
        show = (ListView) findViewById(R.id.show);

        // 为view按钮的单击事件绑定监听器
        view.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                // 清空names、descs、fileNames集合里原有的数据
                names.clear();
                descs.clear();
                fileNames.clear();
                // 通过ContentResolver查询所有图片信息 
                //import android.provider.MediaStore.Images.Media;
                //存储在外部sd卡上的图片文件
                Cursor cursor = getContentResolver().query(
                    Media.EXTERNAL_CONTENT_URI, null, null, null, null);
                while (cursor.moveToNext())
                {
                    // 获取图片的显示名
                    String name = cursor.getString(cursor
                        .getColumnIndex(Media.DISPLAY_NAME));
                    // 获取图片的详细描述
                    String desc = cursor.getString(cursor
                        .getColumnIndex(Media.DESCRIPTION));
                    // 获取图片的保存位置的数据
                    byte[] data = cursor.getBlob(cursor
                        .getColumnIndex(Media.DATA));
                    // 将图片名添加到names集合中
                    names.add(name);
                    // 将图片描述添加到descs集合中
                    descs.add(desc);
                    // 将图片保存路径添加到fileNames集合中
                    fileNames.add(new String(data, 0, data.length - 1));
                }
                // 创建一个List集合，List集合的元素是Map
                List&lt;Map&lt;String, Object&gt;&gt; listItems = new ArrayList&lt;&gt;();
                // 将names、descs两个集合对象的数据转换到Map集合中
                for (int i = 0; i &lt; names.size(); i++)
                {
                    Map&lt;String, Object&gt; listItem = new HashMap&lt;&gt;();
                    listItem.put(&quot;name&quot;, names.get(i));
                    listItem.put(&quot;desc&quot;, descs.get(i));
                    listItems.add(listItem);
                }
                // 创建一个SimpleAdapter
                SimpleAdapter simpleAdapter = new SimpleAdapter(
                    MainActivity.this, listItems ,
                    R.layout.line, new String[] { &quot;name&quot;, &quot;desc&quot; }
                    , new int[] {R.id.name, R.id.desc });
                // 为show ListView组件设置Adapter
                show.setAdapter(simpleAdapter);
            }
        });
        // 为show ListView的列表项单击事件添加监听器
        show.setOnItemClickListener(new OnItemClickListener()
        {
            @Override
            public void onItemClick(AdapterView&lt;?&gt; parent
                , View source, int position, long id)
            {
                // 加载view.xml界面布局代表的视图
                View viewDialog = getLayoutInflater().inflate(
                    R.layout.view, null);
                // 获取viewDialog中ID为image的组件
                ImageView image = (ImageView) viewDialog
                    .findViewById(R.id.image);
                // 设置image显示指定图片
                image.setImageBitmap(BitmapFactory.decodeFile(
                    fileNames.get(position)));
                // 使用对话框显示用户单击的图片
                new AlertDialog.Builder(MainActivity.this)
                    .setView(viewDialog).setPositiveButton(&quot;确定&quot;, null)
                    .show();
            }
        });

        // 为add按钮的单击事件绑定监听器 
        add.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                // 创建ContentValues对象，准备插入数据
                ContentValues values = new ContentValues();
                values.put(Media.DISPLAY_NAME, &quot;jinta&quot;);
                values.put(Media.DESCRIPTION, &quot;金塔&quot;);
                values.put(Media.MIME_TYPE, &quot;image/jpeg&quot;);
                // 插入数据，返回所插入数据对应的Uri
                Uri uri = getContentResolver().insert(
                    Media.EXTERNAL_CONTENT_URI, values);
                // 加载应用程序下的jinta图片
                Bitmap bitmap = BitmapFactory.decodeResource(
                    MainActivity.this.getResources(),
                    R.drawable.jinta);
                System.out.println(&quot;======&quot;);
                OutputStream os = null;
                try
                {
                    // 获取刚插入的数据的Uri对应的输出流
                    os = getContentResolver().openOutputStream(uri); // ①
                    // 将bitmap图片保存到Uri对应的数据节点中
                    bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os);
                    os.close();
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }
            }
        });

    }
}
</code></pre><h1 id="0901_5">监听ContentProvider的数据改变</h1>


<p><a href="#0901">返回目录</a> </p>
<pre><code>    &lt;!-- 授予本应用读取短信的权限 --&gt;
    &lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot;/&gt;

package org.crazyit.content;

import android.app.Activity;
import android.database.ContentObserver;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.view.Menu;
import android.view.MenuItem;

public class MainActivity extends Activity
{
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 为content://sms的数据改变注册监听器
        getContentResolver().registerContentObserver(
            Uri.parse(&quot;content://sms&quot;), true,
            new SmsObserver(new Handler()));
    }
    // 提供自定义的ContentObserver监听器类
    private final class SmsObserver extends ContentObserver
    {
        public SmsObserver(Handler handler)
        {
            super(handler);
        }
        public void onChange(boolean selfChange)
        {
            // 查询发送箱中的短信（处于正在发送状态的短信放在发送箱）
            Cursor cursor = getContentResolver().query(
                Uri.parse(&quot;content://sms/outbox&quot;)
                , null, null, null, null);
            // 遍历查询得到的结果集，即可获取用户正在发送的短信
            while (cursor.moveToNext())
            {
                StringBuilder sb = new StringBuilder();
                // 获取短信的发送地址
                sb.append(&quot;address=&quot;).append(cursor
                    .getString(cursor.getColumnIndex(&quot;address&quot;)));
                // 获取短信的标题
                sb.append(&quot;;subject=&quot;).append(cursor
                    .getString(cursor.getColumnIndex(&quot;subject&quot;)));
                // 获取短信的内容
                sb.append(&quot;;body=&quot;).append(cursor
                    .getString(cursor.getColumnIndex(&quot;body&quot;)));
                // 获取短信的发送时间
                sb.append(&quot;;time=&quot;).append(cursor
                    .getLong(cursor.getColumnIndex(&quot;date&quot;)));
                System.out.println(&quot;发送短信：&quot; + sb.toString());
            }
        }
    }
}
</code></pre><h1 id="1001">1. 绑定服务并通信</h1>

<p><a href="#2">返回目录</a> </p>
<p>服务的运行流程是<br>先服务自己创建，绑定，然后界面和服务连接成功<br>然后服务自己解绑，和销毁</p>
<p><img src="http://i.imgur.com/zGWAF2M.jpg" alt=""><br><img src="http://i.imgur.com/LhNCj79.jpg" alt=""><br>服务的注册</p>
<pre><code>  &lt;service android:name=&quot;.BindService&quot;&gt;
        &lt;/service&gt;
</code></pre><p>绑定服务并通信  <a href="#1001_1">服务的自定义</a></p>
<pre><code>package utilcode.tyq.com.ceshi4;

import android.app.Activity;
import android.app.Service;
import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;

public class MainActivity extends Activity
{
    Button bind, unbind, getServiceStatus;
    // 保持所启动的Service的IBinder对象 启动成功后返回给调用者的一个对象 连接成功是实例化
    BindService.MyBinder binder;
    // 定义一个ServiceConnection对象  监听Activity与服务的连接情况
    private ServiceConnection conn = new ServiceConnection()
    {
        // 当该Activity与Service连接成功时回调该方法
        @Override
        public void onServiceConnected(ComponentName name
                , IBinder service)
        {
            System.out.println(&quot;--Service Connected--&quot;);
            // 获取Service的onBind方法所返回的MyBinder对象
            binder = (BindService.MyBinder) service;  // ①
        }
        // 当该Activity与Service由于异常情况断开连接时回调该方法
        @Override
        public void onServiceDisconnected(ComponentName name)
        {
            System.out.println(&quot;--Service Disconnected--&quot;);
        }
    };
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取程序界面中的start、stop、getServiceStatus按钮
        bind = (Button) findViewById(R.id.bind);
        unbind = (Button) findViewById(R.id.unbind);
        getServiceStatus = (Button) findViewById(R.id.getServiceStatus);
        // 创建启动Service的Intent
        final Intent intent = new Intent(this, BindService.class);
        bind.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 绑定指定Service  Service.BIND_AUTO_CREATE表示服务未创建就创建一个服务
                // 把监听器放到服务中
                bindService(intent, conn, Service.BIND_AUTO_CREATE);
            }
        });
        unbind.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 解除绑定Service  这个是content中的方法 释放监听器
                unbindService(conn);
            }
        });
        getServiceStatus.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 获取、并显示Service的count值 Activity与服务之间对象的传递
                Toast.makeText(MainActivity.this,
                        &quot;Service的count值为：&quot; + binder.getCount(),
                        Toast.LENGTH_SHORT).show();  // ②
            }
        });
    }
}
</code></pre><h1 id="1001_1">1. 服务的自定义</h1>

<p><a href="#1001">返回目录</a> </p>
<pre><code>package utilcode.tyq.com.ceshi4;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;

public class BindService extends Service
{
    private int count;
    private boolean quit;
    // 定义onBinder方法所返回的对象
    private MyBinder binder = new MyBinder();
    // 通过继承Binder来实现IBinder类
    public class MyBinder extends Binder  // ①
    {
        //继承类，并自定义一个方法
        public int getCount()
        {
            // 获取Service的运行状态：count
            return count;
        }
    }
    // 必须实现的方法，绑定该Service时回调该方法
    @Override
    public IBinder onBind(Intent intent)
    {
        System.out.println(&quot;Service is Binded&quot;);
        // 返回IBinder对象
        return binder;
    }
    // Service被创建时回调该方法
    @Override
    public void onCreate()
    {
        super.onCreate();
        System.out.println(&quot;Service is Created&quot;);
        // 启动一条线程，动态地修改count状态值
        new Thread()
        {
            @Override
            public void run()
            {
                while (!quit)
                {
                    try
                    {
                        Thread.sleep(1000);
                    }
                    catch (InterruptedException e)
                    {
                    }
                    count++;
                }
            }
        }.start();
    }
    // Service被断开连接时回调该方法
    @Override
    public boolean onUnbind(Intent intent)
    {
        System.out.println(&quot;Service is Unbinded&quot;);
        return true;
    }
    // Service被关闭之前回调该方法
    @Override
    public void onDestroy()
    {
        super.onDestroy();
        this.quit = true;
        System.out.println(&quot;Service is Destroyed&quot;);
    }
}
</code></pre><h1 id="1002">2. IntentService</h1>

<p><a href="#2">返回目录</a> </p>
<p>IntentService会创建单独的worer线程来处理所有的Intent请求。<br>处理完成后，会自动终止线程。<br><img src="http://i.imgur.com/qhl9bxI.jpg" alt=""></p>
<p>启动服务的代码</p>
<pre><code>public void startService(View source)
    {
        // 创建需要启动的Service的Intent
        Intent intent = new Intent(this, MyService.class);
        // 启动Service
        startService(intent);
    }
    public void startIntentService(View source)
    {
        // 创建需要启动的IntentService的Intent
        Intent intent = new Intent(this, MyIntentService.class);
        // 启动IntentService
        startService(intent);
    }
</code></pre><p>普通服务</p>
<pre><code>package org.crazyit.service;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;

public class MyService extends Service
{
    @Override
    public IBinder onBind(Intent intent)
    {
        return null;
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId)
    {
        // 该方法内执行耗时任务可能导致ANR（Application Not Responding）异常
        long endTime = System.currentTimeMillis() + 20 * 1000;
        System.out.println(&quot;onStart&quot;);
        while (System.currentTimeMillis() &lt; endTime)
        {
            synchronized (this)
            {
                try
                {
                    wait(endTime - System.currentTimeMillis());
                }
                catch (Exception e)
                {
                }
            }
        }
        System.out.println(&quot;---耗时任务执行完成---&quot;);
        return START_STICKY;
    }
}
</code></pre><p>IntentService的实现</p>
<pre><code>package org.crazyit.service;

import android.app.IntentService;
import android.content.Intent;

public class MyIntentService extends IntentService
{
    public MyIntentService()
    {
        super(&quot;MyIntentService&quot;);
    }
    // IntentService会使用单独的线程来执行该方法的代码
    @Override
    protected void onHandleIntent(Intent intent)
    {
        // 该方法内可以执行任何耗时任务，比如下载文件等，此处只是让线程暂停20秒
        long endTime = System.currentTimeMillis() + 20 * 1000;
        System.out.println(&quot;onStartCommand&quot;);
        while (System.currentTimeMillis() &lt; endTime)
        {//线程暂停
            synchronized (this)
            {
                try
                {
                    wait(endTime - System.currentTimeMillis());
                }
                catch (Exception e)
                {
                }
            }
        }
        System.out.println(&quot;---耗时任务执行完成---&quot;);
    }
}
</code></pre><h1 id="1003">1. 电话管理器</h1>

<p><a href="#2">返回目录</a> </p>
<p>SimpleAdapter 适配器的运用<br>需要权限</p>
<p><a href="1003_1">监听手机来电</a></p>
<p><img src="http://i.imgur.com/QUch1T7.jpg" alt=""><br>列表</p>
<pre><code>&lt;ListView 
    android:id=&quot;@+id/show&quot;
    android:layout_width=&quot;match_parent&quot; 
    android:layout_height=&quot;match_parent&quot; 
    android:entries=&quot;@array/statusNames&quot;
    /&gt;
</code></pre><p>字符串列表</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;!-- 声明一个名为statusNames的字符串数组 --&gt;
    &lt;string-array name=&quot;statusNames&quot;&gt;
        &lt;item&gt;设备编号&lt;/item&gt;
        &lt;item&gt;软件版本&lt;/item&gt;
        &lt;item&gt;网络运营商代号&lt;/item&gt;
        &lt;item&gt;网络运营商名称&lt;/item&gt;
        &lt;item&gt;手机制式&lt;/item&gt;
        &lt;item&gt;设备当前位置&lt;/item&gt;
        &lt;item&gt;SIM卡的国别&lt;/item&gt;
        &lt;item&gt;SIM卡序列号&lt;/item&gt;
        &lt;item&gt;SIM卡状态&lt;/item&gt;        
    &lt;/string-array&gt;
    &lt;!-- 声明一个名为simState的字符串数组 --&gt;
    &lt;string-array name=&quot;simState&quot;&gt;
        &lt;item&gt;状态未知&lt;/item&gt;
        &lt;item&gt;无SIM卡&lt;/item&gt;
        &lt;item&gt;被PIN加锁&lt;/item&gt;
        &lt;item&gt;被PUK加锁&lt;/item&gt;
        &lt;item&gt;被NetWork PIN加锁&lt;/item&gt;
        &lt;item&gt;已准备好&lt;/item&gt;
    &lt;/string-array&gt;
    &lt;!-- 声明一个名为phoneType的字符串数组 --&gt;
    &lt;string-array name=&quot;phoneType&quot;&gt;    
        &lt;item&gt;未知&lt;/item&gt;
        &lt;item&gt;GSM&lt;/item&gt;
        &lt;item&gt;CDMA&lt;/item&gt;
    &lt;/string-array&gt;    
&lt;/resources&gt;
</code></pre><p>源代码实现</p>
<pre><code>package utilcode.tyq.com.ceshi4;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.telephony.TelephonyManager;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ListView;
import android.widget.SimpleAdapter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;


public class MainActivity extends Activity
{
    ListView showView;
    // 声明代表状态名的数组
    String[] statusNames;
    // 声明代表手机状态的集合
    ArrayList&lt;String&gt; statusValues = new ArrayList&lt;&gt;();
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取系统的TelephonyManager对象
        TelephonyManager tManager = (TelephonyManager)
                getSystemService(Context.TELEPHONY_SERVICE);
        // 获取各种状态名称的数组
        statusNames = getResources().getStringArray(R.array.statusNames);
        // 获取代表SIM卡状态的数组
        String[] simState = getResources()
                .getStringArray(R.array.simState);
        // 获取代表电话网络类型的数组
        String[] phoneType = getResources().getStringArray(
                R.array.phoneType);
        // 获取设备编号
        statusValues.add(tManager.getDeviceId());
        // 获取系统平台的版本
        statusValues.add(tManager.getDeviceSoftwareVersion()
                != null ? tManager.getDeviceSoftwareVersion() : &quot;未知&quot;);
        // 获取网络运营商代号
        statusValues.add(tManager.getNetworkOperator());
        // 获取网络运营商名称
        statusValues.add(tManager.getNetworkOperatorName());
        // 获取手机网络类型
        statusValues.add(phoneType[tManager.getPhoneType()]);
        // 获取设备所在位置
        statusValues.add(tManager.getCellLocation() != null ? tManager
                .getCellLocation().toString() : &quot;未知位置&quot;);
        // 获取SIM卡的国别
        statusValues.add(tManager.getSimCountryIso());
        // 获取SIM卡序列号
        statusValues.add(tManager.getSimSerialNumber());
        // 获取SIM卡状态
        statusValues.add(simState[tManager.getSimState()]);
        // 获得ListView对象
        showView = (ListView) findViewById(R.id.show);
        ArrayList&lt;Map&lt;String, String&gt;&gt; status = new ArrayList&lt;&gt;();
        // 遍历statusValues集合，将statusNames、statusValues
        // 的数据封装到List&lt;Map&lt;String , String&gt;&gt;集合中
        for (int i = 0; i &lt; statusValues.size(); i++)
        {
            HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
            map.put(&quot;name&quot;, statusNames[i]);
            map.put(&quot;value&quot;, statusValues.get(i));
            status.add(map);
        }
        // 使用SimpleAdapter封装List数据
        SimpleAdapter adapter = new SimpleAdapter(this, status,
                R.layout.line, new String[] { &quot;name&quot;, &quot;value&quot; }
                , new int[] { R.id.name, R.id.value });
        // 为ListView设置Adapter
        showView.setAdapter(adapter);
    }
}
</code></pre><h1 id="1003_1">1. 监听手机来电</h1>

<p><a href="#1003">返回目录</a> </p>
<p>需要权限</p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.telephony.PhoneStateListener;
import android.telephony.TelephonyManager;

import java.io.FileNotFoundException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Date;

public class MainActivity extends Activity
{
    TelephonyManager tManager;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 取得TelephonyManager对象
        tManager = (TelephonyManager)
                getSystemService(Context.TELEPHONY_SERVICE);
        // 创建一个通话状态监听器
        PhoneStateListener listener = new PhoneStateListener()
        {
            @Override
            public void onCallStateChanged(int state, String number)
            {
                switch (state)
                {
                    // 无任何状态
                    case TelephonyManager.CALL_STATE_IDLE:
                        break;
                    case TelephonyManager.CALL_STATE_OFFHOOK:
                        break;
                    // 来电铃响时
                    case TelephonyManager.CALL_STATE_RINGING:
                        OutputStream os = null;
                        try
                        {
                            os = openFileOutput(&quot;phoneList&quot;, MODE_APPEND);
                        }
                        catch (FileNotFoundException e)
                        {
                            e.printStackTrace();
                        }
                        PrintStream ps = new PrintStream(os);
                        // 将来电号码记录到文件中
                        ps.println(new Date() + &quot; 来电：&quot; + number);
                        ps.close();
                        break;
                    default:
                        break;
                }
                super.onCallStateChanged(state, number);
            }
        };
        // 监听电话通话状态的改变
        tManager.listen(listener, PhoneStateListener.LISTEN_CALL_STATE);
    }
}
</code></pre><h1 id="1004">1. 短信管理器</h1>

<p><a href="#2">返回目录</a> </p>
<p>发送短信 需要权限</p>
<pre><code>    // 创建一个PendingIntent对象
                PendingIntent pi = PendingIntent.getActivity(
                        MainActivity.this, 0, new Intent(), 0);
                // 发送短信 分别获取收件人和内容
                sManager.sendTextMessage(number.getText().toString(),
                        null, content.getText().toString(), pi, null);
                // 提示短信发送完成
                Toast.makeText(MainActivity.this, &quot;短信发送完成&quot;, 8000).show();
</code></pre><p>群发短信<br><img src="http://i.imgur.com/ZgqQm2u.png" alt=""></p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.PendingIntent;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.os.Bundle;
import android.provider.ContactsContract;
import android.telephony.SmsManager;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.Toast;

import java.util.ArrayList;


public class MainActivity extends Activity
{
    EditText numbers, content;
    Button select, send;
    SmsManager sManager;
    // 记录需要群发的号码列表
    ArrayList&lt;String&gt; sendList = new ArrayList&lt;String&gt;();
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        sManager = SmsManager.getDefault();
        // 获取界面上的文本框、按钮组件
        numbers = (EditText) findViewById(R.id.numbers);
        content = (EditText) findViewById(R.id.content);
        select = (Button) findViewById(R.id.select);
        send = (Button) findViewById(R.id.send);
        // 为send按钮的单击事件绑定监听器
        send.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                for (String number : sendList)
                {
                    // 创建一个PendingIntent对象
                    PendingIntent pi = PendingIntent.getActivity(
                            MainActivity.this, 0, new Intent(), 0);
                    // 发送短信
                    sManager.sendTextMessage(number, null, content
                            .getText().toString(), pi, null);
                }
                // 提示短信群发完成
                Toast.makeText(MainActivity.this, &quot;短信群发完成&quot;
                        , Toast.LENGTH_SHORT).show();
            }
        });
        // 为select按钮的单击事件绑定监听器
        select.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                // 查询联系人的电话号码 从公共资源中查询联系人
                final Cursor cursor = getContentResolver().query(
                        ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
                        null, null, null, null);
                BaseAdapter adapter = new BaseAdapter()
                {
                    @Override
                    public int getCount()
                    {
                        return cursor.getCount();
                    }
                    @Override
                    public Object getItem(int position)
                    {
                        return position;
                    }
                    @Override
                    public long getItemId(int position)
                    {
                        return position;
                    }
                    @Override
                    public View getView(int position, View convertView,
                                        ViewGroup parent)
                    {
                        cursor.moveToPosition(position);
                        CheckBox rb = new CheckBox(MainActivity.this);
                        // 获取联系人的电话号码，并去掉中间的中画线、空格
                        String number = cursor
                                .getString(cursor.getColumnIndex(ContactsContract
                                        .CommonDataKinds.Phone.NUMBER))
                                .replace(&quot;-&quot;, &quot;&quot;)
                                .replace(&quot; &quot; , &quot;&quot;);
                        rb.setText(number);
                        // 如果该号码已经被加入发送人名单，默认勾选该号码
                        if (isChecked(number))
                        {
                            rb.setChecked(true);
                        }
                        return rb;
                    }
                };
                // 加载list.xml布局文件对应的View
                View selectView = getLayoutInflater().inflate(
                        R.layout.list, null);
                // 获取selectView中的名为list的ListView组件
                final ListView listView = (ListView) selectView
                        .findViewById(R.id.list);
                listView.setAdapter(adapter);
//这个是弹出对话框的代码
                new AlertDialog.Builder(MainActivity.this)
                        .setView(selectView)
                        .setPositiveButton(&quot;确定&quot;,
                                new DialogInterface.OnClickListener()
                                {
                                    @Override
                                    public void onClick(DialogInterface dialog,
                                                        int which)
                                    {
                                        // 清空sendList集合
                                        sendList.clear();
                                        // 遍历listView组件的每个列表项
                                        for (int i = 0; i &lt; listView.getCount(); i++)
                                        {
                                            CheckBox checkBox = (CheckBox) listView
                                                    .getChildAt(i);
                                            // 如果该列表项被勾选
                                            if (checkBox.isChecked())
                                            {
                                                // 添加该列表项的电话号码
                                                sendList.add(checkBox.getText()
                                                        .toString());
                                            }
                                        }
                                        numbers.setText(sendList.toString());
                                    }
                                }).show();
            }
        });
    }
    // 判断某个电话号码是否已在群发范围内
    public boolean isChecked(String phone)
    {
        for (String s1 : sendList)
        {
            if (s1.equals(phone))
            {
                return true;
            }
        }
        return false;
    }
}
</code></pre><h1 id="1005">1. 音频管理器</h1>

<p><a href="#2">返回目录</a> </p>
<p><img src="http://i.imgur.com/OMa078T.jpg" alt=""></p>
<p>静音或正常的按钮</p>
<pre><code>&lt;ToggleButton
    android:id=&quot;@+id/mute&quot;
    android:layout_width=&quot;wrap_content&quot; 
    android:layout_height=&quot;wrap_content&quot; 
    android:textOn=&quot;@string/normal&quot;
    android:textOff=&quot;@string/mute&quot;
/&gt;
</code></pre><p>实现的代码</p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.Service;
import android.media.AudioManager;
import android.media.MediaPlayer;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ToggleButton;


public class MainActivity extends Activity
{
    Button play, up, down;
    ToggleButton mute;
    AudioManager aManager;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取系统的音频服务
        aManager = (AudioManager) getSystemService(
                Service.AUDIO_SERVICE);
        // 获取界面中三个按钮和一个ToggleButton控件
        play = (Button) findViewById(R.id.play);
        up = (Button) findViewById(R.id.up);
        down = (Button) findViewById(R.id.down);
        mute = (ToggleButton) findViewById(R.id.mute);
        // 为play按钮的单击事件绑定监听器
        play.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                //从raw文件夹中读取文件
                // 初始化MediaPlayer对象，准备播放音乐
                MediaPlayer mPlayer = MediaPlayer.create(
                        MainActivity.this, R.raw.earth);
                // 设置循环播放
                mPlayer.setLooping(true);
                // 开始播放
                mPlayer.start();
            }
        });
        up.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // STREAM_MUSIC指定调节音乐的音频，ADJUST_RAISE增大音量，FLAG_SHOW_UI而且显示音量图形示意
                aManager.adjustStreamVolume(AudioManager.STREAM_MUSIC,
                        AudioManager.ADJUST_RAISE, AudioManager.FLAG_SHOW_UI);
            }
        });
        down.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                // 指定调节音乐的音频，降低音量，而且显示音量图形示意
                aManager.adjustStreamVolume(AudioManager.STREAM_MUSIC,
                        AudioManager.ADJUST_LOWER, AudioManager.FLAG_SHOW_UI);
            }
        });
        mute.setOnCheckedChangeListener(new OnCheckedChangeListener()
        {
            @Override
            public void onCheckedChanged(CompoundButton source,
                                         boolean isChecked)
            {
                // 指定调节音乐的音频，根据isChecked确定是否需要静音
                aManager.setStreamMute(AudioManager.STREAM_MUSIC,
                        isChecked);
            }
        });
    }
}
</code></pre><h1 id="1006">1. 振动管理器</h1>

<p><a href="#2">返回目录</a> </p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.Service;
import android.os.Bundle;
import android.os.Vibrator;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.widget.Toast;


public class MainActivity extends Activity
{
    Vibrator vibrator;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取系统的Vibrator服务
        vibrator = (Vibrator) getSystemService(
                Service.VIBRATOR_SERVICE);
    }
    // 重写onTouchEvent方法，当用户触碰触摸屏时触发该方法
    @Override
    public boolean onTouchEvent(MotionEvent event)
    {
        Toast.makeText(this, &quot;手机振动&quot;
                , Toast.LENGTH_SHORT).show();
        // 控制手机振动2秒
        vibrator.vibrate(2000);
        return super.onTouchEvent(event);
    }
}
</code></pre><h1 id="1007">1. 手机闹钟服务</h1>

<p><a href="#2">返回目录</a> </p>
<p><a href="#1007_1">定时更换壁纸</a></p>
<p>全局定时器使用，当宿主进程被杀死以后，运行在宿主进程上的组件也就不存在了。<br>如果进程关闭了，闹钟就不响了<br><img src="http://i.imgur.com/dF7XCtu.jpg" alt=""></p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.media.MediaPlayer;
import android.os.Bundle;

public class AlarmActivity extends Activity
{
    MediaPlayer alarmMusic;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        // 加载指定音乐，并为之创建MediaPlayer对象
        alarmMusic = MediaPlayer.create(this, R.raw.alarm);
        alarmMusic.setLooping(true);
        // 播放音乐
        alarmMusic.start();
        // 创建一个对话框
        new AlertDialog.Builder(AlarmActivity.this).setTitle(&quot;闹钟&quot;)
                .setMessage(&quot;闹钟响了,Go！Go！Go！&quot;)
                .setPositiveButton(&quot;确定&quot;, new OnClickListener()
                {
                    @Override
                    public void onClick(DialogInterface dialog, int which)
                    {
                        // 停止音乐
                        alarmMusic.stop();
                        // 结束该Activity
                        AlarmActivity.this.finish();
                    }
                }).show();
    }
}
</code></pre><p><img src="http://i.imgur.com/qVYss4F.jpg" alt=""></p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.TimePickerDialog;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.TimePicker;
import android.widget.Toast;

import java.util.Calendar;

public class MainActivity extends Activity
{
    Button setTime;
    Calendar currentTime = Calendar.getInstance();
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取程序界面的按钮
        setTime = (Button) findViewById(R.id.setTime);
        // 为“设置闹铃”按钮绑定监听器。
        setTime.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                Calendar currentTime = Calendar.getInstance();
                // 创建一个TimePickerDialog实例，并把它显示出来。
                new TimePickerDialog(MainActivity.this, 0, // 绑定监听器
                    new TimePickerDialog.OnTimeSetListener()
                    {
                        @Override
                        public void onTimeSet(TimePicker tp,
                            int hourOfDay, int minute)
                        {
                            // 指定启动AlarmActivity组件
                            Intent intent = new Intent(MainActivity.this,
                                AlarmActivity.class);
                            // 创建PendingIntent对象  打开一个Activity页面
                            PendingIntent pi = PendingIntent.getActivity(
                                    MainActivity.this, 0, intent, 0);
                            分割时间
                            Calendar c = Calendar.getInstance();
                            c.setTimeInMillis(System.currentTimeMillis());
                            // 根据用户选择时间来设置Calendar对象
                            c.set(Calendar.HOUR, hourOfDay);
                            c.set(Calendar.MINUTE, minute);
                            // 获取AlarmManager对象
                            AlarmManager aManager = (AlarmManager)
                                getSystemService(ALARM_SERVICE);
                            // 设置AlarmManager将在Calendar对应的时间启动指定组件
                            aManager.set(AlarmManager.RTC_WAKEUP,
                                    c.getTimeInMillis(), pi);
                            // 显示闹铃设置成功的提示信息
                            Toast.makeText(MainActivity.this, &quot;闹铃设置成功啦&quot;
                                , Toast.LENGTH_SHORT).show();
                        }
                    }, currentTime.get(Calendar.HOUR_OF_DAY), currentTime
                    .get(Calendar.MINUTE), false).show();
            }
        });
    }
}
</code></pre><h1 id="1007_1">1. 定时更换壁纸</h1>

<p><a href="#1007">返回目录</a> </p>
<p>壁纸管理服务</p>
<pre><code>package org.crazyit.manager;

import android.app.Service;
import android.app.WallpaperManager;
import android.content.Intent;
import android.os.IBinder;

public class ChangeService extends Service
{
    // 定义定时更换的壁纸资源
    int[] wallpapers = new int[]{
            R.drawable.shuangta,
            R.drawable.lijiang,
            R.drawable.qiao,
            R.drawable.shui
    };
    // 定义系统的壁纸管理服务
    WallpaperManager wManager;
    // 定义当前所显示的壁纸
    int current = 0;
    @Override
    public int onStartCommand(Intent intent, int flags, int startId)
    {
        // 如果到了最后一张，系统重新开始
        if(current &gt;= 4)
            current = 0;
        try
        {
            // 改变壁纸
            wManager.setResource(wallpapers[current++]);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return START_STICKY;
    }
    @Override
    public void onCreate()
    {
        super.onCreate();
        // 初始化WallpaperManager
        wManager = WallpaperManager.getInstance(this);
    }
    @Override
    public IBinder onBind(Intent intent)
    {
        return null;
    }
}
</code></pre><p>每5秒钟去启动一个服务</p>
<pre><code>package org.crazyit.manager;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;


public class MainActivity extends Activity
{
    Button start, stop;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        start = (Button) findViewById(R.id.start);
        stop = (Button) findViewById(R.id.stop);
        // 指定启动ChangeService组件
        Intent intent = new Intent(MainActivity.this, ChangeService.class);
        // 创建PendingIntent对象 定时去启动一个服务
        final PendingIntent pi = PendingIntent.getService(MainActivity.this, 0, intent, 0);
        start.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View arg0)
            {
                // 获取AlarmManager对象
                AlarmManager aManager = (AlarmManager) getSystemService(
                    Service.ALARM_SERVICE);
                // 设置每隔5秒执行pi代表的组件一次
                aManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP
                    , 0, 5000, pi);
                start.setEnabled(false);
                stop.setEnabled(true);
                Toast.makeText(MainActivity.this
                    , &quot;壁纸定时更换启动成功啦&quot;,
                    Toast.LENGTH_SHORT).show();
            }
        });
        stop.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View arg0)
            {
            start.setEnabled(true);
            stop.setEnabled(false);
            // 获取AlarmManager对象
            AlarmManager aManager = (AlarmManager) getSystemService(
                Service.ALARM_SERVICE);
            // 取消对pi的调度
            aManager.cancel(pi);
            }
        });
    }
}
</code></pre><h1 id="1008">1. 接受广播服务</h1>

<p><a href="#2">返回目录</a> </p>
<p>这是一个全局的、系统级别的监听器，拥有自己的进程。程序级别的监听器，当程序关闭后，就退出了。<br>如果进程内没有任何活动组件，当内存紧张时，就会有些结束该进程</p>
<p><a href="#1008_1">有序广播</a><br><a href="#1008_2">音乐播放器</a><br>后台负责播放音乐，前台进行控制。通过广播进行通信</p>
<p>简单的广播<br><img src="http://i.imgur.com/p1Sy47J.jpg" alt=""></p>
<pre><code>注册全局广播
&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;
            &lt;intent-filter&gt;
                &lt;!-- 指定该BroadcastReceiver所响应的Intent的Action --&gt;
                &lt;action android:name=&quot;org.crazyit.action.CRAZY_BROADCAST&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;


广播接受的实例
public class MyReceiver extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Toast.makeText(context,
            &quot;接收到的Intent的Action为：&quot; + intent.getAction()
            + &quot;\n消息内容是：&quot; + intent.getStringExtra(&quot;msg&quot;)
            , Toast.LENGTH_LONG).show();
    }
}

发送一条广播
send.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                // 创建Intent对象
                Intent intent = new Intent();
                // 设置Intent的Action属性
                intent.setAction(&quot;org.crazyit.action.CRAZY_BROADCAST&quot;);
                intent.putExtra(&quot;msg&quot;, &quot;简单的消息&quot;);
                // 发送广播
                sendBroadcast(intent);
            }
        });
</code></pre><h1 id="1008_1">1. 有序广播</h1>

<p><a href="#1008">返回目录</a> </p>
<p>注册优先级 两个广播的优先级不同</p>
<pre><code>&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;
            &lt;intent-filter android:priority=&quot;20&quot;&gt;
                &lt;action android:name=&quot;org.crazyit.action.CRAZY_BROADCAST&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;
        &lt;receiver android:name=&quot;.MyReceiver2&quot;&gt;
            &lt;intent-filter android:priority=&quot;0&quot;&gt;
                &lt;action android:name=&quot;org.crazyit.action.CRAZY_BROADCAST&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;
</code></pre><p>发送广播</p>
<pre><code>// 创建Intent对象
                Intent intent = new Intent();
                intent.setAction(&quot;org.crazyit.action.CRAZY_BROADCAST&quot;);
                intent.putExtra(&quot;msg&quot;, &quot;简单的消息&quot;);
                // 发送有序广播
                sendOrderedBroadcast(intent, null);
</code></pre><p>第二个广播</p>
<pre><code>public class MyReceiver2 extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Bundle bundle = getResultExtras(true);
        // 解析前一个BroadcastReceiver所存入的key为first的消息
        String first = bundle.getString(&quot;first&quot;);
        Toast.makeText(context, &quot;第一个Broadcast存入的消息为：&quot;
            + first, Toast.LENGTH_LONG).show();
    }
}
</code></pre><p>第一个广播</p>
<pre><code>public class MyReceiver extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Toast.makeText(context,    &quot;接收到的Intent的Action为：&quot;
                + intent.getAction() + &quot;\n消息内容是：&quot;
                + intent.getStringExtra(&quot;msg&quot;)
                , Toast.LENGTH_LONG).show();
        // 创建一个Bundle对象，并存入数据
        Bundle bundle = new Bundle();
        bundle.putString(&quot;first&quot;, &quot;第一个BroadcastReceiver存入的消息&quot;);
        // 将bundle放入结果中
        setResultExtras(bundle);
        // 取消Broadcast的继续传播
        //abortBroadcast(); // ①
    }
}
</code></pre><h1 id="1008_2">1. 音乐播放器</h1>

<p><a href="#1008">返回目录</a> </p>
<p><img src="http://i.imgur.com/sJ1WkjM.jpg" alt=""></p>
<p>activity与服务中各注册了一个监听器，相互监听，因为采用了后台播放程序，所以就是退出程序，只要进程还在，音乐就可以正常播放。<br>前台</p>
<pre><code>package org.crazyit.broadcast;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
import android.widget.TextView;

public class MainActivity extends Activity implements OnClickListener
{
    // 获取界面中显示歌曲标题、作者文本框
    TextView title, author;
    // 播放/暂停、停止按钮
    ImageButton play, stop;
    ActivityReceiver activityReceiver;
    public static final String CTL_ACTION =
            &quot;org.crazyit.action.CTL_ACTION&quot;;
    public static final String UPDATE_ACTION =
            &quot;org.crazyit.action.UPDATE_ACTION&quot;;
    // 定义音乐的播放状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停
    int status = 0x11;
    String[] titleStrs = new String[] { &quot;心愿&quot;, &quot;约定&quot;, &quot;美丽新世界&quot; };
    String[] authorStrs = new String[] { &quot;未知艺术家&quot;, &quot;周蕙&quot;, &quot;伍佰&quot; };
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取程序界面界面中的两个按钮
        play = (ImageButton) this.findViewById(R.id.play);
        stop = (ImageButton) this.findViewById(R.id.stop);
        title = (TextView) findViewById(R.id.title);
        author = (TextView) findViewById(R.id.author);
        // 为两个按钮的单击事件添加监听器
        play.setOnClickListener(this);
        stop.setOnClickListener(this);
        页面注册广播
        activityReceiver = new ActivityReceiver();
        // 创建IntentFilter
        IntentFilter filter = new IntentFilter();
        // 指定BroadcastReceiver监听的Action
        filter.addAction(UPDATE_ACTION);
        // 注册BroadcastReceiver
        registerReceiver(activityReceiver, filter);
        开启服务
        Intent intent = new Intent(this, MusicService.class);
        // 启动后台Service
        startService(intent);
    }
    // 自定义的BroadcastReceiver，负责监听从Service传回来的广播
    public class ActivityReceiver extends BroadcastReceiver
    {
        @Override
        public void onReceive(Context context, Intent intent)
        {
            // 获取Intent中的update消息，update代表播放状态
            int update = intent.getIntExtra(&quot;update&quot;, -1);
            // 获取Intent中的current消息，current代表当前正在播放的歌曲
            int current = intent.getIntExtra(&quot;current&quot;, -1);
            -1代表返回的默认值
            if (current &gt;= 0)
            {
                title.setText(titleStrs[current]);
                author.setText(authorStrs[current]);
            }
            switch (update)
            {
                case 0x11:
                    play.setImageResource(R.drawable.play);
                    status = 0x11;
                    break;
                // 控制系统进入播放状态
                case 0x12:
                    // 播放状态下设置使用暂停图标
                    play.setImageResource(R.drawable.pause);
                    // 设置当前状态
                    status = 0x12;
                    break;
                // 控制系统进入暂停状态
                case 0x13:
                    // 暂停状态下设置使用播放图标
                    play.setImageResource(R.drawable.play);
                    // 设置当前状态
                    status = 0x13;
                    break;
            }
        }
    }
    @Override
    public void onClick(View source)
    {
        // 创建Intent
        Intent intent = new Intent(&quot;org.crazyit.action.CTL_ACTION&quot;);
        switch (source.getId())
        {
            // 按下播放/暂停按钮
            case R.id.play:
                intent.putExtra(&quot;control&quot;, 1);
                break;
            // 按下停止按钮
            case R.id.stop:
                intent.putExtra(&quot;control&quot;, 2);
                break;
        }
        // 发送广播，将被Service组件中的BroadcastReceiver接收到
        sendBroadcast(intent);
    }
}
</code></pre><p>后台</p>
<pre><code>package org.crazyit.broadcast;

import java.io.IOException;

import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.res.AssetFileDescriptor;
import android.content.res.AssetManager;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnCompletionListener;
import android.os.IBinder;

public class MusicService extends Service
{
    MyReceiver serviceReceiver;
    AssetManager am;
    String[] musics = new String[] { &quot;wish.mp3&quot;, &quot;promise.mp3&quot;,
            &quot;beautiful.mp3&quot; };
    MediaPlayer mPlayer;
    // 当前的状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停
    int status = 0x11;
    // 记录当前正在播放的音乐
    int current = 0;
    @Override
    public IBinder onBind(Intent intent)
    {
        return null;
    }
    @Override
    public void onCreate()
    {
        super.onCreate();
        am = getAssets();
        // 创建BroadcastReceiver
        serviceReceiver = new MyReceiver();
        // 创建IntentFilter
        IntentFilter filter = new IntentFilter();
        filter.addAction(MainActivity.CTL_ACTION);
        registerReceiver(serviceReceiver, filter);
        // 创建MediaPlayer
        mPlayer = new MediaPlayer();
        // 为MediaPlayer播放完成事件绑定监听器
        mPlayer.setOnCompletionListener(new OnCompletionListener() // ①
        {
            @Override
            public void onCompletion(MediaPlayer mp)
            {
                current++;
                if (current &gt;= 3)
                {
                    current = 0;
                }
                //发送广播通知Activity更改文本框
                Intent sendIntent = new Intent(MainActivity.UPDATE_ACTION);
                sendIntent.putExtra(&quot;current&quot;, current);
                // 发送广播，将被Activity组件中的BroadcastReceiver接收到
                sendBroadcast(sendIntent);
                // 准备并播放音乐
                prepareAndPlay(musics[current]);
            }
        });
    }
    public class MyReceiver extends BroadcastReceiver
    {
        @Override
        public void onReceive(final Context context, Intent intent)
        {
            int control = intent.getIntExtra(&quot;control&quot;, -1);
            switch (control)
            {
                // 播放或暂停
                case 1:
                    // 原来处于没有播放状态
                    if (status == 0x11)
                    {
                        // 准备并播放音乐
                        prepareAndPlay(musics[current]);
                        status = 0x12;
                    }
                    // 原来处于播放状态
                    else if (status == 0x12)
                    {
                        // 暂停
                        mPlayer.pause();
                        // 改变为暂停状态
                        status = 0x13;
                    }
                    // 原来处于暂停状态
                    else if (status == 0x13)
                    {
                        // 播放
                        mPlayer.start();
                        // 改变状态
                        status = 0x12;
                    }
                    break;
                // 停止声音
                case 2:
                    // 如果原来正在播放或暂停
                    if (status == 0x12 || status == 0x13)
                    {
                        // 停止播放
                        mPlayer.stop();
                        status = 0x11;
                    }
            }
            // 广播通知Activity更改图标、文本框
            Intent sendIntent = new Intent(MainActivity.UPDATE_ACTION);
            sendIntent.putExtra(&quot;update&quot;, status);
            sendIntent.putExtra(&quot;current&quot;, current);
            // 发送广播，将被Activity组件中的BroadcastReceiver接收到
            sendBroadcast(sendIntent);
        }
    }
    private void prepareAndPlay(String music)
    {
        try
        {
            // 打开指定音乐文件
            AssetFileDescriptor afd = am.openFd(music);
            mPlayer.reset();
            // 使用MediaPlayer加载指定的声音文件。
            mPlayer.setDataSource(afd.getFileDescriptor(),
                    afd.getStartOffset(), afd.getLength());
            // 准备声音
            mPlayer.prepare();
            // 播放
            mPlayer.start();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }
}
</code></pre><h1 id="1009">1. 接受系统广播</h1>

<p><a href="#2">返回目录</a> </p>
<p>开机自动运行服务</p>
<pre><code>开机运行的权限
&lt;!-- 授予应用程序访问系统开机事件的权限 --&gt;
    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;

&lt;!-- 定义一个BroadcastReceiver,监听系统开机广播  --&gt;
        &lt;receiver android:name=&quot;.LaunchReceiver&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;

public class LaunchReceiver extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Intent tIntent = new Intent(context
                , LaunchService.class);
        // 启动指定Service
        context.startService(tIntent);
    }
}


public class LaunchService extends Service
{
    @Override
    public IBinder onBind(Intent intent)
    {
        return null;
    }
    @Override
    public void onCreate()
    {
        // 定义1秒执行一行输出
        new Timer().schedule(new TimerTask()
        {

            @Override
            public void run()
            {
                System.out.println(&quot;-----&quot;
                        + new Date() + &quot;-----&quot;);
            }
        }, 0, 1000);
    }
}
</code></pre><p>短信提醒</p>
<pre><code>&lt;receiver android:name=&quot;SmsReceiver&quot;&gt;
            &lt;intent-filter android:priority=&quot;1000&quot;&gt;
                &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;

&lt;!-- 授予程序接收短信的权限 --&gt;
    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt;


package org.crazyit.broadcast;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.telephony.SmsMessage;
import android.widget.Toast;

import java.text.SimpleDateFormat;
import java.util.Date;

public class SmsReceiver extends BroadcastReceiver
{
    // 当接收到短信时被触发
    @Override
    public void onReceive(Context context, Intent intent)
    {
        // 如果是接收到短信
        if (intent.getAction().equals(
                &quot;android.provider.Telephony.SMS_RECEIVED&quot;))
        {
            // 取消广播（这行代码将会让系统收不到短信）
            abortBroadcast();  // ①
            StringBuilder sb = new StringBuilder();
            // 接收由SMS传过来的数据
            Bundle bundle = intent.getExtras();
            // 判断是否有数据
            if (bundle != null)
            {
                // 通过pdus可以获得接收到的所有短信消息
                Object[] pdus = (Object[]) bundle.get(&quot;pdus&quot;);
                // 构建短信对象array,并依据收到的对象长度来创建array的大小
                SmsMessage[] messages = new SmsMessage[pdus.length];
                for (int i = 0; i &lt; pdus.length; i++)
                {
                    messages[i] = SmsMessage
                            .createFromPdu((byte[]) pdus[i]);
                }
                // 将发送来的短信合并自定义信息于StringBuilder当中
                for (SmsMessage message : messages)
                {
                    sb.append(&quot;短信来源:&quot;);
                    // 获得接收短信的电话号码
                    sb.append(message.getDisplayOriginatingAddress());
                    sb.append(&quot;\n------短信内容------\n&quot;);
                    // 获得短信的内容
                    sb.append(message.getDisplayMessageBody());
                }
            }
            Toast.makeText(context, sb.toString()
                    , Toast.LENGTH_LONG).show();
        }
    }
</code></pre><p>电量提醒</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.BATTERY_STATS&quot;/&gt;

&lt;receiver android:name=&quot;.BatteryReceiver&quot;&gt;
            &lt;!-- 监听电池电量改变 --&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.BATTERY_CHANGED&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;

package org.crazyit.broadcast;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.widget.Toast;

public class BatteryReceiver extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        System.out.println(&quot;+++++++++++++++++++++++&quot;);
        Bundle bundle = intent.getExtras();
        // 获取当前电量
        int current = bundle.getInt(&quot;level&quot;);
        // 获取总电量
        int total = bundle.getInt(&quot;scale&quot;);
        // 如果当前电量小于总电量的15%
        if (current * 1.0 / total &lt; 0.15)
        {
            Toast.makeText(context, &quot;电量过低，请尽快充电！&quot;
                    , Toast.LENGTH_LONG).show();
        }
    }
}
</code></pre><h1 id="0301">基于监听的事件处理</h1>

<p><a href="#1">返回目录</a> </p>
<p>就是界面组件绑定特定的事件监听器。是一种更面向对象的事件处理。分为事件源，事件，事件监听器（一个特殊的Java对象）。是一种委派式的事件处理方式。<br>回调，就是重写组件特定的回调方法，或重写Activity的回调方法。处理一些具有通用性的事件。</p>
<p><a href="#0301_1">基于监听的事件处理模型</a><br><a href="#0301_2">事件和事件监听器</a><br><a href="#0301_3">外部类作为事件监听器类</a><br>Activity本身作为事件监听器。<br>匿名内部类作为事件监听器<br>还有一种就是直接绑定到标签</p>
<h1 id="0301_1">基于监听的事件处理模型</h1>

<p><a href="#0301">返回目录</a> </p>
<pre><code>// 获取应用程序中的bn按钮
        Button bn = (Button) findViewById(R.id.bn);
        // 为按钮绑定事件监听器
        bn.setOnClickListener(new MyClickListener()); // ①


// 定义一个单击事件的监听器
    class MyClickListener implements View.OnClickListener
    {
        // 实现监听器类必须实现的方法，该方法将会作为事件处理器
        @Override
        public void onClick(View v)
        {
            EditText txt = (EditText) findViewById(R.id.txt);
            txt.setText(&quot;bn按钮被单击了！&quot;);
        }
    }
</code></pre><h1 id="0301_2">事件和事件监听器</h1>

<p><a href="#0301">返回目录</a> </p>
<p>这种多数采用内部类作为事件监听器，可以访问调用它的各个内部组件，所以比较普及。</p>
<p><img src="http://i.imgur.com/3w0Qi2K.jpg" alt=""></p>
<p>绘制一个飞机</p>
<pre><code>package org.crazyit.event;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.view.View;

public class PlaneView extends View
{//通过设置这两个值，来设计飞机的位置
    public float currentX;
    public float currentY;
    Bitmap plane;
    public PlaneView(Context context)
    {
        super(context);
        // 定义飞机图片
        plane = BitmapFactory.decodeResource(context.getResources(),
            R.drawable.plane);
        setFocusable(true);
    }
    @Override
    public void onDraw(Canvas canvas)
    {
        super.onDraw(canvas);
        // 创建画笔
        Paint p = new Paint();
        // 绘制飞机
        canvas.drawBitmap(plane, currentX, currentY, p);
    }
}
</code></pre><p>启动键盘的事件监听器</p>
<pre><code>package org.crazyit.event;

import android.app.Activity;
import android.os.Bundle;
import android.util.DisplayMetrics;
import android.view.Display;
import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnKeyListener;
import android.view.Window;
import android.view.WindowManager;


public class MainActivity extends Activity
{
    // 定义飞机的移动速度
    private int speed = 10;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        // 去掉窗口标题
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        // 全屏显示
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                WindowManager.LayoutParams.FLAG_FULLSCREEN);
        // 创建PlaneView组件
        final PlaneView planeView = new PlaneView(this);
        setContentView(planeView);
        planeView.setBackgroundResource(R.drawable.back);
        // 获取窗口管理器
        WindowManager windowManager = getWindowManager();
        Display display = windowManager.getDefaultDisplay();
        DisplayMetrics metrics = new DisplayMetrics();
        // 获得屏幕宽和高
        display.getMetrics(metrics);
        // 设置飞机的初始位置
        planeView.currentX = metrics.widthPixels / 2;
        planeView.currentY = metrics.heightPixels - 100;
        // 为planeView组件的键盘事件绑定监听器
        planeView.setOnKeyListener(new OnKeyListener()
        {
            @Override
            public boolean onKey(View source, int keyCode, KeyEvent event)
            {
                // 获取由哪个键触发的事件
                switch (event.getKeyCode())
                {
                    // 控制飞机下移
                    case KeyEvent.KEYCODE_S:
                        planeView.currentY += speed;
                        break;
                    // 控制飞机上移
                    case KeyEvent.KEYCODE_W:
                        planeView.currentY -= speed;
                        break;
                    // 控制飞机左移
                    case KeyEvent.KEYCODE_A:
                        planeView.currentX -= speed;
                        break;
                    // 控制飞机右移
                    case KeyEvent.KEYCODE_D:
                        planeView.currentX += speed;
                        break;
                }
                // 通知planeView组件重绘
                planeView.invalidate();
                return true;
            }
        });
    }
}
</code></pre><h1 id="0301_3">外部类作为事件监听器类</h1>

<p><a href="#0301">返回目录</a> </p>
<p>能为多个界面所共享，完成某种业务逻辑。可以写成抽象方法，运用泛型，调用的时候再去试下接口的方法。<br><img src="http://i.imgur.com/nYP6fHt.jpg" alt=""></p>
<p>定义的外部类监听器</p>
<pre><code>package org.crazyit.event;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.Intent;
import android.telephony.SmsManager;
import android.view.View;
import android.view.View.OnLongClickListener;
import android.widget.EditText;
import android.widget.Toast;

public class SendSmsListener implements OnLongClickListener
{
    private Activity act;
    private EditText address;
    private EditText content;
    public SendSmsListener(Activity act, EditText address
        , EditText content)
    {
        this.act = act;
        this.address = address;
        this.content = content;
    }
    @Override
    public boolean onLongClick(View source)
    {
        String addressStr = address.getText().toString();
        String contentStr = content.getText().toString();
        // 获取短信管理器 负责发送短信
        SmsManager smsManager = SmsManager.getDefault();
        // 创建发送短信的PendingIntent
        PendingIntent sentIntent = PendingIntent.getBroadcast(act
                , 0, new Intent(), 0);
        // 发送文本短信
        smsManager.sendTextMessage(addressStr, null, contentStr
                , sentIntent, null);
        Toast.makeText(act, &quot;短信发送完成&quot;, Toast.LENGTH_LONG).show();
        return false;
    }
}
</code></pre><p>界面调用外部类的逻辑</p>
<pre><code>package org.crazyit.event;

import android.app.Activity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.Button;
import android.widget.EditText;


public class MainActivity extends Activity
{
    EditText address;
    EditText content;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 获取页面中收件人地址、短信内容
        address = (EditText)findViewById(R.id.address);
        content = (EditText)findViewById(R.id.content);
        Button bn = (Button)findViewById(R.id.send);
        // 使用外部类的实例作为事件监听器
        bn.setOnLongClickListener(new SendSmsListener(
            this , address, content));
    }
}
</code></pre><h1 id="0302">基于回调的事件处理</h1>

<p><a href="#1">返回目录</a> </p>
<p>基于回调的事件处理模型，事件源和事件监听器是统一的。安卓为所有的组件提供了一些事件处理的回调方法。</p>
<p><a href="#0302_1">基于回调的事件传播</a><br><a href="#0302_2">通过回调实现跟随手指的小球</a></p>
<h1 id="0302_1">基于回调的事件传播</h1>

<p><a href="#0302">返回目录</a> </p>
<p>这个没能实现，总是出现错误。<br><img src="http://i.imgur.com/x5deVDB.jpg" alt=""><br>系统最先触发的是按键上绑定的事件监听器</p>
<pre><code>Button bn = (Button) findViewById(R.id.bn);
        // 为bn绑定事件监听器
        bn.setOnKeyListener(new OnKeyListener() {
            @Override
            public boolean onKey(View source
                    , int keyCode, KeyEvent event) {
                // 只处理按下键的事件
                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    Log.v(&quot;-Listener-&quot;, &quot;the onKeyDown in Listener&quot;);
                }
                // 返回false，表明该事件会向外传播
                return true; // ①
            }
        });
</code></pre><p>然后触发的是组件提供的事件回调方法</p>
<pre><code>package org.crazyit.event;

import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.view.KeyEvent;
import android.widget.Button;

public class MyButton extends Button
{
    public MyButton(Context context , AttributeSet set)
    {
        super(context , set);
    }
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        super.onKeyDown(keyCode , event);
        Log.v(&quot;-MyButton-&quot;, &quot;the onKeyDown in MyButton&quot;);
        // 返回false，表明并未完全处理该事件，该事件依然向外扩散
        return false;
    }
}
</code></pre><p>最后传播到组件所在的Activity</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    &gt;
    &lt;!-- 使用自定义View时应使用全限定类名 --&gt;
    &lt;studydiary.tyq.com.ceshi1.MyButton
        android:id=&quot;@+id/bn&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;单击我&quot;/&gt;
&lt;/LinearLayout&gt;


// 重写onKeyDown方法，该方法可监听它所包含的所有组件的按键被按下事件
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)
    {
        super.onKeyDown(keyCode , event);
        Log.v(&quot;-Activity-&quot; , &quot;the onKeyDown in Activity&quot;);
        //返回false，表明并未完全处理该事件，该事件依然向外扩散
        return false;
    }
</code></pre><p>如果任何一个事件处理方法返回true，事件将不会继续向外传播。如果返回false，事件将会继续传播到下一层。</p>
<h1 id="0302_2">通过回调实现跟随手指的小球</h1>

<p><a href="#0302">返回目录</a> </p>
<p><img src="http://i.imgur.com/Mbatq5N.jpg" alt=""><br>通过回调的方法把事件处理方法封装在View内部，可以提高程序的内聚性，更适合处理事件逻辑比较固定的view</p>
<pre><code>&lt;!-- 使用自定义组件 --&gt;
    &lt;org.crazyit.event.DrawView
        android:orientation=&quot;vertical&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;/&gt;

package org.crazyit.event;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;

public class DrawView extends View
{
    public float currentX = 40;
    public float currentY = 50;
    // 定义、创建画笔
    Paint p = new Paint();
    public DrawView(Context context, AttributeSet set)
    {
        super(context, set);
    }
    //这个方法在两个地方调用  一个是刚开始的时候，一个是重绘的时候
    // 画布的大小就是这个控件的大小
    @Override
    public void onDraw(Canvas canvas)
    {
        super.onDraw(canvas);
        // 设置画笔的颜色
        p.setColor(Color.RED);
        // 绘制一个小圆（作为小球） 15为半径
        canvas.drawCircle(currentX, currentY, 15, p);
    }
    @Override
    public boolean onTouchEvent(MotionEvent event)
    {
        // 当前组件的currentX、currentY两个属性
        this.currentX = event.getX();
        this.currentY = event.getY();
        // 通知改组件重绘
        this.invalidate();
        // 返回true表明处理方法已经处理该事件
        return true;
    }
}
</code></pre><h1 id="0303">相应系统设置的事件和响应系统设置的更改</h1>

<p><a href="#1">返回目录</a> </p>
<p><img src="http://i.imgur.com/UFhuiAv.jpg" alt=""><br><img src="http://i.imgur.com/kd9Dvx3.jpg" alt=""></p>
<pre><code>bn.setOnClickListener(new OnClickListener()
        {
            // 为按钮绑定事件监听器
            @Override
            public void onClick(View source)
            {
                // 获取系统的Configuration对象
                Configuration cfg = getResources().getConfiguration();

                String screen = cfg.orientation ==
                    Configuration.ORIENTATION_LANDSCAPE
                    ? &quot;横向屏幕&quot;: &quot;竖向屏幕&quot;;
                //这个是移动网络代号
                String mncCode = cfg.mnc + &quot;&quot;;

                String naviName = cfg.orientation ==
                    Configuration.NAVIGATION_NONAV
                    ? &quot;没有方向控制&quot; :
                    cfg.orientation == Configuration.NAVIGATION_WHEEL
                        ? &quot;滚轮控制方向&quot; :
                        cfg.orientation == Configuration.NAVIGATION_DPAD
                        ? &quot;方向键控制方向&quot; : &quot;轨迹球控制方向&quot;;
                navigation.setText(naviName);

                String touchName = cfg.touchscreen ==
                    Configuration.TOUCHSCREEN_NOTOUCH
                    ? &quot;无触摸屏&quot; : &quot;支持触摸屏&quot;;
                ori.setText(screen);
                mnc.setText(mncCode);
                touch.setText(touchName);
            }
        });
</code></pre><p>响应系统设置的更改<br><img src="http://i.imgur.com/k6trkeS.jpg" alt=""></p>
<pre><code>&lt;!-- 设置Activity可以监听屏幕方向改变的事件 --&gt;
        &lt;activity
            android:configChanges=&quot;orientation|screenSize&quot;
            android:name=&quot;.MainActivity&quot;
            android:label=&quot;@string/app_name&quot; &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;


Button bn = (Button) findViewById(R.id.bn);
        // 为按钮绑定事件监听器
        bn.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View source) {
                Configuration config = getResources().getConfiguration();
                // 如果当前是横屏
                if (config.orientation == Configuration.ORIENTATION_LANDSCAPE) {
                    // 设为竖屏
                    MainActivity.this.setRequestedOrientation(
                        ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
                }
                // 如果当前是竖屏
                if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
                    // 设为横屏
                    MainActivity.this.setRequestedOrientation(
                        ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
                }
            }
        });


// 重写该方法，用于监听系统设置的更改，主要是监控屏幕方向的更改
    @Override
    public void onConfigurationChanged(Configuration newConfig)
    {
        super.onConfigurationChanged(newConfig);
        String screen = newConfig.orientation ==
            Configuration.ORIENTATION_LANDSCAPE ? &quot;横向屏幕&quot; : &quot;竖向屏幕&quot;;
        Toast.makeText(this, &quot;系统的屏幕方向发生改变&quot; + &quot;\n修改后的屏幕方向为：&quot;
                + screen, Toast.LENGTH_LONG).show();
    }
</code></pre><h1 id="0304">Handler消息传递机制</h1>

<p><a href="#1">返回目录</a> </p>
<p><a href="#0304_1">自动播放的动画</a><br><a href="#0304_2">使用新线程计算质数</a></p>
<p>主线程Main Thread，把相关的事件分发给对应的组件去处理。Handler是另外一种形式的事件处理，主要是为了解决多线程的问题，它允许新线程周期性的改变界面组件的属性值。</p>
<h1 id="-">作用有两个：</h1>
<p>1 在新线程中发送消息。<br>2在主线程中获取和处理消息。<br>原理 主要是通过回调的方式来实现。</p>
<h1 id="0304_1">自动播放的动画</h1>

<p><a href="#0304">返回目录</a> </p>
<p><img src="http://i.imgur.com/BMXLoWF.jpg" alt=""></p>
<pre><code>package org.crazyit.handler;

import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ImageView;

import java.util.Timer;
import java.util.TimerTask;

public class MainActivity extends Activity
{
    // 定义周期性显示的图片的ID
    int[] imageIds = new int[]
        {
            R.drawable.java,
            R.drawable.javaee,
            R.drawable.ajax,
            R.drawable.android,
            R.drawable.swift
        };
    int currentImageId = 0;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        final ImageView show = (ImageView) findViewById(R.id.show);
        final Handler myHandler = new Handler()
        {
            @Override
            public void handleMessage(Message msg)
            {
                // 如果该消息是本程序所发送的
                if (msg.what == 0x1233)
                {
                    // 动态地修改所显示的图片
                    show.setImageResource(imageIds[currentImageId++
                            % imageIds.length]);
                }
            }
        };
        // 定义一个计时器，让该计时器周期性地执行指定任务
        //TimerTask 本质就是启动一条新线程
        new Timer().schedule(new TimerTask()
        {
            @Override
            public void run()
            {
                // 发送空消息
                myHandler.sendEmptyMessage(0x1233);
            }
        }, 0, 1200);
    }
}
</code></pre><h1 id="0304_2">使用新线程计算质数</h1>

<p><a href="#0304">返回目录</a> </p>
<p>Message Handler接受和处理的消息对象<br>Looper 每个线程只能有一个，它的loop方法复制读取MessageQueue中的消息，读到消息之后就把消息交给发送消息的Handler进行处理。<br>MessageQueue 消息队列，采用先进先从的方式来管理Message，<br>程序创建Looper对象是，会在他的构造器中创建MessageQueue对象。</p>
<p>程序员自己启动的线程，必须自己创建一个Looper对象，并启动它，也就是调用它的prepare()方法。这个方法保证每个线程最多只有一个Looper对象。Looper对象调用静态的loop（）方法，使用一个死循环不断的取出MessageQueue中的消息。</p>
<p><img src="http://i.imgur.com/kv3MNEv.jpg" alt=""></p>
<pre><code>package org.crazyit.handler;

import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.view.View;
import android.widget.EditText;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.List;

public class MainActivity extends Activity
{
    static final String UPPER_NUM = &quot;upper&quot;;
    EditText etNum;
    CalThread calThread;
    // 定义一个线程类
    class CalThread extends Thread
    {
        public Handler mHandler;
        public void run()
        {
            Looper.prepare();//创建一个Looper的对象
            mHandler = new Handler()
            {
                // 定义处理消息的方法
                @Override
                public void handleMessage(Message msg)
                {
                    if(msg.what == 0x123)
                    {
                        int upper = msg.getData().getInt(UPPER_NUM);
                        List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();
                        // 计算从2开始、到upper的所有质数
                        outer:
                        for (int i = 2 ; i &lt;= upper ; i++)
                        {
                            // 用i除以从2开始、到i的平方根的所有数
                            for (int j = 2 ; j &lt;= Math.sqrt(i) ; j++)
                            {
                                // 如果可以整除，则表明这个数不是质数
                                if(i != 2 &amp;&amp; i % j == 0)
                                {
                                    continue outer;
                                }
                            }
                            nums.add(i);
                        }
                        // 使用Toast显示统计出来的所有质数  土司出来
                        Toast.makeText(MainActivity.this, nums.toString()
                            , Toast.LENGTH_LONG).show();
                    }
                }
            };
            Looper.loop();//启动Looper
        }
    }
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        etNum = (EditText)findViewById(R.id.etNum);
        calThread = new CalThread();
        // 启动新线程
        calThread.start();
    }
    // 为按钮的点击事件提供事件处理方法
    public void cal(View source)
    {
        // 创建消息
        Message msg = new Message();
        msg.what = 0x123;
        Bundle bundle = new Bundle();
        bundle.putInt(UPPER_NUM ,
                Integer.parseInt(etNum.getText().toString()));
        msg.setData(bundle);
        // 向新线程中的Handler发送消息
        calThread.mHandler.sendMessage(msg);
    }
}
</code></pre><h1 id="0305">异步任务</h1>

<p><a href="#1">返回目录</a> </p>
<p><img src="http://i.imgur.com/ZUj9Jj8.jpg" alt=""></p>
<p>针对新线程不能更新UI组件的问题，几种方案<br>1 使用Handler实现线程之间的通信<br>2 Activity.runOnUiThread(Runnable)<br>3 View.post(Runnable)<br>4 View.postDelayed(Runnable,long)<br>5 异步任务类。</p>
<p>规则<br>必须在UI线程中创建实例，<br>主线程中调用execute()方法。<br>每个AsyncTask只能被执行一次，多次调用将会引发异常。</p>
<pre><code>package studydiary.tyq.com.ceshi1;
import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Context;
import android.os.AsyncTask;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.TextView;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;

public class MainActivity extends Activity {
    private TextView show;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        show = (TextView) findViewById(R.id.show);
    }
    // 重写该方法，为界面的按钮提供事件响应方法
    public void download(View source) throws MalformedURLException
    {
        DownTask task = new DownTask(this);
        task.execute(new URL(&quot;http://211.149.169.221:8080/umijoyappsvr/distribution/DistributionUserList.do?start=0&amp;limit=15&quot;));
    }
    //三个泛型参数 Params 启动任务执行的输入参数的类型  Progress 后台任务完成的进度值的类型
    // Result 后台执行任务完成后返回结果的类型
    class DownTask extends AsyncTask&lt;URL, Integer, String&gt;
    {
        // 可变长的输入参数，与AsyncTask.exucute()对应
        ProgressDialog pdialog;
        // 定义记录已经读取行的数量
        int hasRead = 0;
        Context mContext;
        public DownTask(Context ctx)
        {
            mContext = ctx;
        }
        //后台线程将要完成的任务  调用publishProgress方法更新任务的执行进度
        @Override
        protected String doInBackground(URL... params)
        {
            StringBuilder sb = new StringBuilder();
            try
            {
                URLConnection conn = params[0].openConnection();
                // 打开conn连接对应的输入流，并将它包装成BufferedReader
                BufferedReader br = new BufferedReader(
                        new InputStreamReader(conn.getInputStream()
                                , &quot;utf-8&quot;));
                String line = null;
                while ((line = br.readLine()) != null)
                {
                    sb.append(line + &quot;\n&quot;);
                    hasRead++;
                    publishProgress(hasRead);
                }
                //这个的值有onPostExecute 接受和使用这个值
                return sb.toString();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
            return null;
        }
        //当doInBackground（）完成后，系统后自动调用该方法。并将doInBackground()方法的返回值传给该方法。
        @Override
        protected void onPostExecute(String result)
        {
            // 返回HTML页面的内容
            show.setText(result);
            pdialog.dismiss();
        }
        //这个方法将在耗时操作启动前调用，做一些初始化的准备工作
        @Override
        protected void onPreExecute()
        {
            pdialog = new ProgressDialog(mContext);
            // 设置对话框的标题
            pdialog.setTitle(&quot;任务正在执行中&quot;);
            // 设置对话框显示的内容
            pdialog.setMessage(&quot;任务正在执行中，敬请等待...&quot;);
            // 设置对话框不能用“取消”按钮关闭
            pdialog.setCancelable(false);
            // 设置该进度条的最大进度值
            pdialog.setMax(202);
            // 设置对话框的进度条风格
            pdialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            // 设置对话框的进度条是否显示进度
            pdialog.setIndeterminate(false);
            pdialog.show();
        }

        //在doInBackground()方法中调用publishProgress()方法更新任务的执行进度后，触发该方法
        @Override
        protected void onProgressUpdate(Integer... values)
        {
            // 更新进度
            show.setText(&quot;已经读取了【&quot; + values[0] + &quot;】行！&quot;);
            pdialog.setProgress(values[0]);
        }
    }
}
</code></pre><h1 id="0401">1. 使用Activity</h1>

<p><a href="#1">返回目录</a> </p>
<p><a href="#0401_1">配置设置参数的Activity</a><br><a href="#0401_2">Activity跳转时交换数据</a><br><a href="#0401_3">启动Activity并返回结果</a><br><a href="#0401_4">Activity生命周期和加载模式</a></p>
<p><img src="http://i.imgur.com/mt8fJNc.jpg" alt=""></p>
<p>一个点击项对应一个参数</p>
<pre><code>public class MainActivity extends LauncherActivity
{
    //定义两个Activity的名称
    String[] names = {&quot;设置程序参数&quot; ,  &quot;查看星际兵种&quot;};
    //定义两个Activity对应的实现类
    Class&lt;?&gt;[] clazzs = {PreferenceActivityTest.class
            , ExpandableListActivityTest.class};
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,
                android.R.layout.simple_list_item_1 , names);
        // 设置该窗口显示的列表所需的Adapter
        setListAdapter(adapter);
    }
    //根据列表项返回指定Activity对应的Intent
    @Override
    public Intent intentForPosition(int position)
    {
        return new Intent(MainActivity.this , clazzs[position]);
    }
}
</code></pre><p><img src="http://i.imgur.com/gTR38SP.jpg" alt=""></p>
<pre><code>package org.crazyit.app;

import android.app.ExpandableListActivity;
import android.os.Bundle;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListAdapter;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

public class ExpandableListActivityTest extends ExpandableListActivity
{
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        ExpandableListAdapter adapter = new BaseExpandableListAdapter()
        {
            //以下是设置内部类的变量
            int[] logos = new int[]
                    {
                            R.drawable.p,
                            R.drawable.z,
                            R.drawable.t
                    };
            private String[] armTypes = new String[]
                    { &quot;神族兵种&quot;, &quot;虫族兵种&quot;, &quot;人族兵种&quot;};
            private String[][] arms = new String[][]
                    {
                            { &quot;狂战士&quot;, &quot;龙骑士&quot;, &quot;黑暗圣堂&quot;, &quot;电兵&quot; },
                            { &quot;小狗&quot;, &quot;刺蛇&quot;, &quot;飞龙&quot;, &quot;自爆飞机&quot; },
                            { &quot;机枪兵&quot;, &quot;护士MM&quot; , &quot;幽灵&quot; }
                    };
            //获取指定组位置、指定子列表项处的子列表项数据
            @Override
            public Object getChild(int groupPosition, int childPosition)
            {
                return arms[groupPosition][childPosition];
            }
            @Override
            public long getChildId(int groupPosition, int childPosition)
            {
                return childPosition;
            }
            @Override
            public int getChildrenCount(int groupPosition)
            {
                return arms[groupPosition].length;
            }
            //自定义一个文本框
            private TextView getTextView()
            {
                AbsListView.LayoutParams lp = new AbsListView.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT, 64);
                TextView textView = new TextView(ExpandableListActivityTest.
                        this);
                textView.setLayoutParams(lp);
                textView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
                textView.setPadding(36, 0, 0, 0);
                textView.setTextSize(20);
                return textView;
            }
            //该方法决定每个子选项的外观
            @Override
            public View getChildView(int groupPosition, int childPosition,
                                     boolean isLastChild, View convertView, ViewGroup parent)
            {
                TextView textView = getTextView();
                textView.setText(getChild(groupPosition, childPosition).
                        toString());
                return textView;
            }
            //获取指定组位置处的组数据
            @Override
            public Object getGroup(int groupPosition)
            {
                return armTypes[groupPosition];
            }
            @Override
            public int getGroupCount()
            {
                return armTypes.length;
            }
            @Override
            public long getGroupId(int groupPosition)
            {
                return groupPosition;
            }
            //该方法决定每个组选项的外观
            @Override
            public View getGroupView(int groupPosition, boolean isExpanded,
                                     View convertView, ViewGroup parent)
            {
                LinearLayout ll = new LinearLayout(
                        ExpandableListActivityTest.this);
                ll.setOrientation(LinearLayout.HORIZONTAL);
                ImageView logo = new ImageView(
                        ExpandableListActivityTest.this);
                logo.setImageResource(logos[groupPosition]);
                ll.addView(logo);
                TextView textView = getTextView();
                textView.setText(getGroup(groupPosition).toString());
                ll.addView(textView);
                return ll;
            }
            @Override
            public boolean isChildSelectable(int groupPosition,
                                             int childPosition)
            {
                return true;
            }
            @Override
            public boolean hasStableIds()
            {
                return true;
            }
        };
        // 设置该窗口显示列表
        setListAdapter(adapter);
    }
}
</code></pre><h1 id="0401_1">1. 配置设置参数的Activity</h1>

<p><a href="#0401">返回目录</a><br><img src="http://i.imgur.com/GEnQHlf.jpg" alt=""></p>
<p>app节点 右键 Android resource file建立资源文件<br>布局是</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;preference-headers
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;!-- 指定启动指定PreferenceFragment的列表项 --&gt;
    &lt;header android:fragment=
                &quot;utilcode.tyq.com.ceshi4.PreferenceActivityTest$Prefs1Fragment&quot;
            android:icon=&quot;@drawable/ic_settings_applications&quot;
            android:title=&quot;程序选项设置&quot;
            android:summary=&quot;设置应用的相关选项&quot; /&gt;
    &lt;!-- 指定启动指定PreferenceFragment的列表项 --&gt;
    &lt;header android:fragment=
                &quot;utilcode.tyq.com.ceshi4.PreferenceActivityTest$Prefs2Fragment&quot;
            android:icon=&quot;@drawable/ic_settings_display&quot;
            android:title=&quot;界面选项设置 &quot;
            android:summary=&quot;设置显示界面的相关选项&quot;&gt;
        &lt;!-- 使用extra可向Activity传入额外的数据 --&gt;
        &lt;extra android:name=&quot;website&quot;
               android:value=&quot;www.crazyit.org&quot; /&gt;
    &lt;/header&gt;
    &lt;!-- 使用Intent启动指定Activity的列表项 --&gt;
    &lt;header
        android:icon=&quot;@drawable/ic_settings_display&quot;
        android:title=&quot;使用Intent&quot;
        android:summary=&quot;使用Intent启动某个Activity&quot;&gt;
        &lt;intent android:action=&quot;android.intent.action.VIEW&quot;
                android:data=&quot;http://www.crazyit.org&quot; /&gt;
    &lt;/header&gt;
&lt;/preference-headers&gt;
</code></pre><p>实现的代码是</p>
<pre><code>package utilcode.tyq.com.ceshi4;

import android.os.Bundle;
import android.preference.PreferenceActivity;
import android.preference.PreferenceFragment;
import android.widget.Button;
import android.widget.Toast;

import java.util.List;

public class PreferenceActivityTest extends PreferenceActivity
{
    @Override
    protected void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        // 该方法用于为该界面设置一个标题按钮
        if (hasHeaders())
        {
            Button button = new Button(this);
            button.setText(&quot;设置操作&quot;);
            // 将该按钮添加到该界面上
            setListFooter(button);
        }
    }
    // 重写该该方法，负责加载页面布局文件
    @Override
    public void onBuildHeaders(List&lt;Header&gt; target)
    {
        // 加载选项设置列表的布局文件
        loadHeadersFromResource(R.xml.preference_headers, target);
    }
    // 重写该方法，验证各PreferenceFragment是否有效
    @Override
    public boolean isValidFragment(String fragmentName)
    {
        return true;
    }
    //这个是内部类 Fragment
    public static class Prefs1Fragment extends PreferenceFragment
    {
        @Override
        public void onCreate(Bundle savedInstanceState)
        {
            super.onCreate(savedInstanceState);
            addPreferencesFromResource(R.xml.preferences);
        }
    }
    public static class Prefs2Fragment extends PreferenceFragment
    {
        @Override
        public void onCreate(Bundle savedInstanceState)
        {
            super.onCreate(savedInstanceState);
            addPreferencesFromResource(R.xml.display_prefs);
            // 获取传入该Fragment的参数
            String website = getArguments().getString(&quot;website&quot;);
            Toast.makeText(getActivity()
                    , &quot;网站域名是：&quot; + website , Toast.LENGTH_LONG).show();
        }
    }
}
</code></pre><p>两个Fragment的布局是<br><img src="http://i.imgur.com/f8YN01o.jpg" alt=""></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;PreferenceScreen
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;!-- 设置系统铃声 --&gt;
    &lt;RingtonePreference
        android:ringtoneType=&quot;all&quot;
        android:title=&quot;设置铃声&quot;
        android:summary=&quot;选择铃声（测试RingtonePreference)&quot;
        android:showDefault=&quot;true&quot;
        android:key=&quot;ring_key&quot;
        android:showSilent=&quot;true&quot;&gt;
    &lt;/RingtonePreference&gt;
    &lt;PreferenceCategory android:title=&quot;个人信息设置组&quot;&gt;
        &lt;!-- 通过输入框填写用户名 --&gt;
        &lt;EditTextPreference
            android:key=&quot;name&quot;
            android:title=&quot;填写用户名&quot;
            android:summary=&quot;填写您的用户名（测试EditTextPreference)&quot;
            android:dialogTitle=&quot;您所使用的用户名为：&quot; /&gt;
        &lt;!-- 通过列表框选择性别 --&gt;
        &lt;ListPreference
            android:key=&quot;gender&quot;
            android:title=&quot;性别&quot;
            android:summary=&quot;选择您的性别（测试ListPreference）&quot;
            android:dialogTitle=&quot;ListPreference&quot;
            android:entries=&quot;@array/gender_name_list&quot;
            android:entryValues=&quot;@array/gender_value_list&quot; /&gt;
    &lt;/PreferenceCategory&gt;
    &lt;PreferenceCategory android:title=&quot;系统功能设置组 &quot;&gt;
        &lt;CheckBoxPreference
            android:key=&quot;autoSave&quot;
            android:title=&quot;自动保存进度&quot;
            android:summaryOn=&quot;自动保存: 开启&quot;
            android:summaryOff=&quot;自动保存: 关闭&quot;
            android:defaultValue=&quot;true&quot; /&gt;
    &lt;/PreferenceCategory&gt;
&lt;/PreferenceScreen&gt;
</code></pre><p><img src="http://i.imgur.com/r3DdCDN.jpg" alt=""></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;PreferenceScreen
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;PreferenceCategory android:title=&quot;背景灯光组&quot;&gt;
    &lt;!-- 通过列表框选择灯光强度 --&gt;
    &lt;ListPreference
        android:key=&quot;light&quot;
        android:title=&quot;灯光强度&quot;
        android:summary=&quot;请选择灯光强度（测试ListPreference）&quot;
        android:dialogTitle=&quot;请选择灯光强度&quot;
        android:entries=&quot;@array/light_strength_list&quot;
        android:entryValues=&quot;@array/light_value_list&quot; /&gt;
&lt;/PreferenceCategory&gt;
&lt;PreferenceCategory android:title=&quot;文字显示组 &quot;&gt;
    &lt;!-- 通过SwitchPreference设置是否自动滚屏 --&gt;
    &lt;SwitchPreference
        android:key=&quot;autoScroll&quot;
        android:title=&quot;自动滚屏&quot;
        android:summaryOn=&quot;自动滚屏: 开启&quot;
        android:summaryOff=&quot;自动滚屏: 关闭&quot;
        android:defaultValue=&quot;true&quot; /&gt;
&lt;/PreferenceCategory&gt;
&lt;/PreferenceScreen&gt;
</code></pre><h1 id="0401_2">1. Activity跳转时携带参数</h1>

<p><a href="#0401">返回目录</a><br><img src="http://i.imgur.com/1kkbZZm.jpg" alt=""><br>实现的代码</p>
<pre><code>定义的可实例化对象
public class Person implements Serializable{
public Person(String name, String passwd, String gender) {
        this.name = name;
        this.passwd = passwd;
        this.gender = gender;
    }
}


传递数据
EditText name = (EditText)findViewById(R.id.name);
                EditText passwd = (EditText)findViewById(R.id.passwd);
                RadioButton male = (RadioButton) findViewById(R.id.male);
                String gender = male.isChecked() ? &quot;男 &quot; : &quot;女&quot;;
                Person p = new Person(name.getText().toString(), passwd
                        .getText().toString(), gender);
                // 创建一个Bundle对象
                Bundle data = new Bundle();
                data.putSerializable(&quot;person&quot;, p);
                // 创建一个Intent
                Intent intent = new Intent(MainActivity.this,
                        ResultActivity.class);
                intent.putExtras(data);
                // 启动intent对应的Activity
                startActivity(intent);

接受数据
// 获取启动该Activity的Intent
        Intent intent = getIntent();
        // 直接通过Intent取出它所携带的Bundle数据包中的数据
        Person p = (Person) intent.getSerializableExtra(&quot;person&quot;);
        name.setText(&quot;您的用户名为：&quot; + p.getName());
        passwd.setText(&quot;您的密码为：&quot; + p.getPasswd());
        gender.setText(&quot;您的性别为：&quot; + p.getGender());
</code></pre><p>这个布局有网格布局来实现 </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TableLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;
    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;请输入您的注册信息&quot;
        android:textSize=&quot;20sp&quot;/&gt;
    这个是网格布局的一列
    &lt;TableRow&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;用户名:&quot;
            android:textSize=&quot;16sp&quot;/&gt;
        &lt;!-- 定义一个EditText，用于收集用户的账号 --&gt;
        &lt;EditText
            android:id=&quot;@+id/name&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:hint=&quot;请填写想注册的账号&quot;
            android:selectAllOnFocus=&quot;true&quot;/&gt;
    &lt;/TableRow&gt;
    这个是网格布局的一列
    &lt;TableRow&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;密码:&quot;
            android:textSize=&quot;16sp&quot;/&gt;
        &lt;!-- 用于收集用户的密码 --&gt;
        &lt;EditText
            android:id=&quot;@+id/passwd&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:password=&quot;true&quot;
            android:selectAllOnFocus=&quot;true&quot;/&gt;
    &lt;/TableRow&gt;
    &lt;TableRow&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;性别:&quot;
            android:textSize=&quot;16sp&quot;/&gt;
        &lt;!-- 定义一组单选框，用于收集用户注册的性别 --&gt;
        &lt;RadioGroup
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:orientation=&quot;horizontal&quot;&gt;
            &lt;RadioButton
                android:id=&quot;@+id/male&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;男&quot;
                android:textSize=&quot;16sp&quot;/&gt;
            &lt;RadioButton
                android:id=&quot;@+id/female&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;女&quot;
                android:textSize=&quot;16sp&quot;/&gt;
        &lt;/RadioGroup&gt;
    &lt;/TableRow&gt;
    &lt;Button
        android:id=&quot;@+id/bn&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;注册&quot;
        android:textSize=&quot;16sp&quot;/&gt;
&lt;/TableLayout&gt;
</code></pre><h1 id="0401_3">1. 启动Activity并返回结果</h1>

<p><a href="#0401">返回目录</a><br><img src="http://i.imgur.com/BP4lcxD.jpg" alt=""><br><img src="http://i.imgur.com/vRdCHez.jpg" alt=""><br>启动页面代码</p>
<pre><code>// 创建需要对应于目标Activity的Intent
                Intent intent = new Intent(MainActivity.this,
                        SelectCityActivity.class);
                // 启动指定Activity并等待返回的结果，其中0是请求码，用于标识该请求
                startActivityForResult(intent, 0);


// 重写该方法，该方法以回调的方式来获取指定Activity返回的结果
    @Override
    public void onActivityResult(int requestCode
            , int resultCode, Intent intent)
    {
        // 当requestCode、resultCode同时为0时，也就是处理特定的结果
        if (requestCode == 0 &amp;&amp; resultCode == 0)
        {
            // 取出Intent里的Extras数据
            Bundle data = intent.getExtras();
            // 取出Bundle中的数据
            String resultCity = data.getString(&quot;city&quot;);
            // 修改city文本框的内容
            city.setText(resultCity);
        }
    }
</code></pre><p>返回数据页面代码 </p>
<pre><code>package org.crazyit.app;

import android.app.ExpandableListActivity;
import android.content.Intent;
import android.os.Bundle;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnChildClickListener;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

public class SelectCityActivity extends ExpandableListActivity
{
    // 定义省份数组
    private String[] provinces = new String[]
        { &quot;广东&quot;, &quot;广西&quot;, &quot;湖南&quot;};
    private String[][] cities = new String[][]
        {
            { &quot;广州&quot;, &quot;深圳&quot;, &quot;珠海&quot;, &quot;中山&quot; },
            { &quot;桂林&quot;, &quot;柳州&quot;, &quot;南宁&quot;, &quot;北海&quot; },
            { &quot;长沙&quot;, &quot;岳阳&quot; , &quot;衡阳&quot; , &quot;株洲&quot; }
        };
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        ExpandableListAdapter adapter = new BaseExpandableListAdapter()
        {
            // 获取指定组位置、指定子列表项处的子列表项数据
            @Override
            public Object getChild(int groupPosition, int childPosition)
            {
                return cities[groupPosition][childPosition];
            }
            @Override
            public long getChildId(int groupPosition, int childPosition)
            {
                return childPosition;
            }
            @Override
            public int getChildrenCount(int groupPosition)
            {
                return cities[groupPosition].length;
            }
            private TextView getTextView()
            {
                AbsListView.LayoutParams lp = new AbsListView.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT, 64);
                TextView textView = new TextView(SelectCityActivity.this);
                textView.setLayoutParams(lp);
                textView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
                textView.setPadding(36, 0, 0, 0);
                textView.setTextSize(20);
                return textView;
            }
            // 该方法决定每个子选项的外观
            @Override
            public View getChildView(int groupPosition, int childPosition,
                boolean isLastChild, View convertView, ViewGroup parent)
            {
                TextView textView = getTextView();
                textView.setText(getChild(groupPosition, childPosition)
                        .toString());
                return textView;
            }
            // 获取指定组位置处的组数据
            @Override
            public Object getGroup(int groupPosition)
            {
                return provinces[groupPosition];
            }
            @Override
            public int getGroupCount()
            {
                return provinces.length;
            }
            @Override
            public long getGroupId(int groupPosition)
            {
                return groupPosition;
            }
            // 该方法决定每个组选项的外观
            @Override
            public View getGroupView(int groupPosition, boolean isExpanded,
                View convertView, ViewGroup parent)
            {
                LinearLayout ll = new LinearLayout(SelectCityActivity.this);
                ll.setOrientation(LinearLayout.HORIZONTAL);
                ImageView logo = new ImageView(SelectCityActivity.this);
                ll.addView(logo);
                TextView textView = getTextView();
                textView.setText(getGroup(groupPosition).toString());
                ll.addView(textView);
                return ll;
            }
            @Override
            public boolean isChildSelectable(int groupPosition,
                int childPosition)
            {
                return true;
            }
            @Override
            public boolean hasStableIds()
            {
                return true;
            }
        };
        // 设置该窗口显示列表
        setListAdapter(adapter);
        getExpandableListView().setOnChildClickListener(
            new OnChildClickListener()
            {
                @Override
                public boolean onChildClick(ExpandableListView parent,
                    View source, int groupPosition, int childPosition,
                                            long id)
                {
                    // 获取启动该Activity之前的Activity对应的Intent
                    Intent intent = getIntent();
                    intent.putExtra(&quot;city&quot;,
                            cities[groupPosition][childPosition]);
                    // 设置该SelectCityActivity的结果码，并设置结束之后退回的Activity
                    SelectCityActivity.this.setResult(0, intent);
                    // 结束SelectCityActivity。
                    SelectCityActivity.this.finish();
                    return false;
                }
            });
    }
}
</code></pre><h1 id="0401_4">1. Activity生命周期和加载模式</h1>

<p><a href="#0401">返回目录</a> </p>
<p><img src="http://i.imgur.com/MMAHp64.jpg" alt=""><br>Activity是有Task栈来管理的。<br>android:launchMode=&quot;singleTask&quot;</p>
<h1 id="standard-">standard 标准模式 默认</h1>
<p><img src="http://i.imgur.com/N9hCTrg.jpg" alt=""><br>tv.setText(&quot;Activity为：&quot; + this.toString()</p>
<pre><code>        + &quot;\n&quot; + &quot;，Task ID为:&quot; + this.getTaskId());
</code></pre><p>不同的实例，所在的Task ID是相同的，但hashCode值有差异</p>
<h1 id="singletop-task-">singleTop Task栈顶单例模式</h1>
<p>实例在栈顶不创建，没在栈顶，就创建新实例。</p>
<h1 id="singletask-task-">singleTask Task内单例模式</h1>
<h1 id="singgleinstance-">singgleInstance 全局单例模式</h1>
<pre><code>&lt;activity android:name=&quot;.SecondActivity&quot;
                  android:label=&quot;@string/second&quot;
                  &lt;!-- 这个表明应用可以被其他隐形Intent调用 --&gt;
                  android:exported=&quot;true&quot;
                  android:launchMode=&quot;singleInstance&quot;&gt;
            &lt;intent-filter&gt;
                &lt;!-- 指定该Activity能响应Action为指定字符串的Intent --&gt;
                &lt;action android:name=&quot;org.crazyit.intent.action.CRAZYIT_ACTION&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
</code></pre><h1 id="0402">1. Fragment</h1>

<p><a href="#1">返回目录</a> </p>
<p>这个被称为片段。</p>
<p><a href="#0402_1">显示详情的Fragment</a><br><a href="#0402_2">兼顾屏幕分辨率的应用</a><br><a href="#0402_3">Fragment的生命周期</a></p>
<h1 id="0402_1">显示详情的Fragment</h1>

<p><a href="#0402">返回目录</a> </p>
<p><img src="http://i.imgur.com/bN4P7B1.jpg" alt=""></p>
<p>先自定义一个类</p>
<pre><code>package utilcode.tyq.com.ceshi4;

import android.app.Activity;
import android.app.ListFragment;
import android.os.Bundle;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.ListView;

public class BookListFragment extends ListFragment
{
    private Callbacks mCallbacks;
    // 定义一个回调接口，该Fragment所在Activity需要实现该接口
    // 该Fragment将通过该接口与它所在的Activity交换数据
    public interface Callbacks
    {
        public void onItemSelected(Integer id);
    }
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        // 为该ListFragment设置Adapter BookContent.ITEMS是放入了数据
        setListAdapter(new ArrayAdapter&lt;BookContent.Book&gt;(getActivity(),
                android.R.layout.simple_list_item_activated_1,
                android.R.id.text1, BookContent.ITEMS));  //①
    }
    // 当该Fragment被添加、显示到Activity时，回调该方法
    @Override
    public void onAttach(Activity activity)
    {
        super.onAttach(activity);
        // 如果Activity没有实现Callbacks接口，抛出异常
        if (!(activity instanceof Callbacks))
        {
            throw new IllegalStateException(
                    &quot;BookListFragment所在的Activity必须实现Callbacks接口!&quot;);
        }
        // 刚进入时 把该Activity当成Callbacks对象
        mCallbacks = (Callbacks)activity;
    }
    // 当该Fragment从它所属的Activity中被删除时回调该方法
    @Override
    public void onDetach()
    {
        super.onDetach();
        // 将mCallbacks赋为null。
        mCallbacks = null;
    }
    // 当用户单击某列表项时激发该回调方法
    @Override
    public void onListItemClick(ListView listView
        , View view, int position, long id)
    {
        super.onListItemClick(listView, view, position, id);
        // 激发mCallbacks的onItemSelected方法
        mCallbacks.onItemSelected(BookContent
                .ITEMS.get(position).id);
    }
    public void setActivateOnItemClick(boolean activateOnItemClick)
    {
        getListView().setChoiceMode(
            activateOnItemClick ? ListView.CHOICE_MODE_SINGLE
            : ListView.CHOICE_MODE_NONE);
    }
}
</code></pre><p>定义主要的布局，在主要的布局中加入自定义的类</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!-- 定义一个水平排列的LinearLayout，并指定使用中等分隔条 --&gt;
&lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:layout_marginLeft=&quot;16dp&quot;
    android:layout_marginRight=&quot;16dp&quot;
    android:divider=&quot;?android:attr/dividerHorizontal&quot;
    android:showDividers=&quot;middle&quot;&gt;
    &lt;!-- 添加一个Fragment 左边的目录 在设置布局时就已经加入进来--&gt;
    &lt;fragment
        android:name=&quot;utilcode.tyq.com.ceshi4.BookListFragment&quot;
        android:id=&quot;@+id/book_list&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot; /&gt;
    &lt;!-- 添加一个FrameLayout容器 右边的--&gt;
    &lt;FrameLayout
        android:id=&quot;@+id/book_detail_container&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;3&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>定义主页面的代码 每次点击的时候初始化Fragment</p>
<pre><code>package utilcode.tyq.com.ceshi4;
import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.TimePickerDialog;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.TimePicker;
import android.widget.Toast;

import java.util.Calendar;

public class MainActivity extends Activity implements
        BookListFragment.Callbacks
{
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        // 加载/res/layout目录下的activity_book_twopane.xml布局文件
        setContentView(R.layout.activity_book_twopane);
    }
    // 实现Callbacks接口必须实现的方法 只有点击时才实现的方法 每点击一次
    //携带的参数都会发生改变
    @Override
    public void onItemSelected(Integer id)
    {
        // 创建Bundle，准备向Fragment传入参数
        Bundle arguments = new Bundle();
        arguments.putInt(BookDetailFragment.ITEM_ID, id);
        // 创建BookDetailFragment对象
        BookDetailFragment fragment = new BookDetailFragment();
        // 向Fragment传入参数
        fragment.setArguments(arguments);
        // 使用fragment替换book_detail_container容器当前显示的Fragment beginTransaction开启事务
动态的更新了容器中的内容 getFragmentManager().beginTransaction()代表Activity对Fragment执行的多个改变
        getFragmentManager().beginTransaction()
                .replace(R.id.book_detail_container, fragment)
                .commit();  // ①
    }

}
</code></pre><p>每次点击的时候的片段和它的布局</p>
<pre><code>package utilcode.tyq.com.ceshi4;

import android.app.Fragment;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

public class BookDetailFragment extends Fragment
{
    public static final String ITEM_ID = &quot;item_id&quot;;
    // 保存该Fragment显示的Book对象
    BookContent.Book book;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        // 如果启动该Fragment时包含了ITEM_ID参数 根据传入的参数获取图书的信息
        if (getArguments().containsKey(ITEM_ID))
        {//在这里，初始化数据对象
            book = BookContent.ITEM_MAP.get(getArguments()
                .getInt(ITEM_ID)); // ①
        }
    }
    // 重写该方法，该方法返回的View将作为Fragment显示的组件
    @Override
    public View onCreateView(LayoutInflater inflater
        , ViewGroup container, Bundle savedInstanceState)
    {
        // 加载/res/layout/目录下的fragment_book_detail.xml布局文件
        View rootView = inflater.inflate(R.layout.fragment_book_detail,
                container, false);
        if (book != null)
        {
            // 让book_title文本框显示book对象的title属性
            ((TextView) rootView.findViewById(R.id.book_title))
                .setText(book.title);
            // 让book_desc文本框显示book对象的desc属性
            ((TextView) rootView.findViewById(R.id.book_desc))
                .setText(book.desc);
        }
        return rootView;
    }
}



&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;
    &lt;!-- 定义一个TextView来显示图书标题 --&gt;
    &lt;TextView
        style=&quot;?android:attr/textAppearanceLarge&quot;
        android:id=&quot;@+id/book_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:padding=&quot;16dp&quot;/&gt;
    &lt;!-- 定义一个TextView来显示图书描述 --&gt;
    &lt;TextView
        style=&quot;?android:attr/textAppearanceMedium&quot;
        android:id=&quot;@+id/book_desc&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:padding=&quot;16dp&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre><p>模拟系统的数据类型</p>
<pre><code>package utilcode.tyq.com.ceshi4;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BookContent
{
    // 定义一个内部类，作为系统的业务对象
    public static class Book
    {
        public Integer id;
        public String title;
        public String desc;
        public Book(Integer id, String title, String desc)
        {
            this.id = id;
            this.title = title;
            this.desc = desc;
        }
        @Override
        public String toString()
        {
            return title;
        }
    }
    // 使用List集合记录系统所包含的Book对象
    public static List&lt;Book&gt; ITEMS = new ArrayList&lt;Book&gt;();
    // 使用Map集合记录系统所包含的Book对象
    public static Map&lt;Integer, Book&gt; ITEM_MAP
            = new HashMap&lt;Integer, Book&gt;();
    static
    {  //利用构造器来初始化类的信息
        // 使用静态初始化代码，将Book对象添加到List集合、Map集合中
        addItem(new Book(1, &quot;疯狂Java讲义&quot;
                , &quot;一本全面、深入的Java学习图书，已被多家高校选做教材。&quot;));
        addItem(new Book(2, &quot;疯狂Android讲义&quot;
                , &quot;Android学习者的首选图书，常年占据京东、当当、 &quot;
                + &quot;亚马逊3大网站Android销量排行榜的榜首&quot;));
        addItem(new Book(3, &quot;轻量级Java EE企业应用实战&quot;
                , &quot;全面介绍Java EE开发的Struts 2、Spring 3、Hibernate 4框架&quot;));
    }
    private static void addItem(Book book)
    {
        ITEMS.add(book);
        ITEM_MAP.put(book.id, book);
    }
}
</code></pre><h1 id="0402_2">兼顾屏幕分辨率的应用</h1>

<p><a href="#0402">返回目录</a> </p>
<p><img src="http://i.imgur.com/80fVWJl.jpg" alt=""><br>建立资源文件夹 values-large<br>refs.xml  在打屏幕手机上activity_book_list文件会取代activity_book_twopane</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;!-- 定义activity_book_list实际引用@layout/activity_book_twopane资源 --&gt;
    &lt;item type=&quot;layout&quot; name=&quot;activity_book_list&quot;&gt;
        @layout/activity_book_twopane&lt;/item&gt;
&lt;/resources&gt;
</code></pre><p>Activity根据不同的分辨率进行分别处理</p>
<pre><code>package org.crazyit.app;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;

public class BookListActivity extends Activity implements
        BookListFragment.Callbacks
{
    // 定义一个旗标，用于标识该应用是否支持大屏幕
    private boolean mTwoPane;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        // 指定加载R.layout.activity_book_list对应的界面布局文件
        // 但实际上该应用会根据屏幕分辨率加载不同的界面布局文件
        setContentView(R.layout.activity_book_list);
        // 如果加载的界面布局文件中包含ID为book_detail_container的组件
        if (findViewById(R.id.book_detail_container) != null)
        {
            mTwoPane = true; //这个就表示是大屏幕
            ((BookListFragment) getFragmentManager()
                    .findFragmentById(R.id.book_list))
                    .setActivateOnItemClick(true);
        }
    }
    @Override
    public void onItemSelected(Integer id)
    {
        if (mTwoPane)
        {//大屏幕
            // 创建Bundle，准备向Fragment传入参数
            Bundle arguments = new Bundle();
            arguments.putInt(BookDetailFragment.ITEM_ID, id);
            // 创建BookDetailFragment对象
            BookDetailFragment fragment = new BookDetailFragment();
            // 向Fragment传入参数
            fragment.setArguments(arguments);
            // 使用fragment替换book_detail_container容器当前显示的Fragment
            getFragmentManager().beginTransaction()
                    .replace(R.id.book_detail_container, fragment).commit();
        }
        else
        {
            // 创建启动BookDetailActivity的Intent
            Intent detailIntent = new Intent(this, BookDetailActivity.class);
            // 设置传给BookDetailActivity的参数
            detailIntent.putExtra(BookDetailFragment.ITEM_ID, id);
            // 启动Activity
            startActivity(detailIntent);
        }
    }
}
</code></pre><p>Activity页面加载一个Fragment</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/book_detail_container&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;/&gt;


package org.crazyit.app;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.MenuItem;

public class BookDetailActivity extends Activity
{
    @Override
    protected void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        // 指定加载/res/layout目录下的activity_book_detail.xml布局文件
        // 该界面布局文件内只定义了一个名为book_detail_container的FrameLayout
        setContentView(R.layout.activity_book_detail);
        // 将ActionBar上应用图标转换成可点击的按钮
        getActionBar().setDisplayHomeAsUpEnabled(true);
        if (savedInstanceState == null)
        {
            // 创建BookDetailFragment对象
            BookDetailFragment fragment = new BookDetailFragment();
            // 创建Bundle对象，
            Bundle arguments = new Bundle();
            arguments.putInt(BookDetailFragment.ITEM_ID, getIntent()
                    .getIntExtra(BookDetailFragment.ITEM_ID, 0));
            // 向Fragment传入参数
            fragment.setArguments(arguments);
            // 将指定fragment添加到book_detail_container容器中
            getFragmentManager().beginTransaction()
                    .add(R.id.book_detail_container, fragment).commit();
        }
    }
    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        if (item.getItemId() == android.R.id.home)
        {
            // 创建启动BookListActivity的Intent
            Intent intent = new Intent(this, BookListActivity.class);
            // 添加额外的Flag，将Activity栈中处于FirstActivity之上的Activity弹出
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            // 启动intent对应的Activity
            startActivity(intent);
            return true;
        }
        return super.onOptionsItemSelected(item);
    }
}
</code></pre><h1 id="0402_3">Fragment的生命周期</h1>

<p><a href="#0402">返回目录</a><br>启动Fragment时的回调方法<br><img src="http://i.imgur.com/rfVfOu0.jpg" alt=""><br>其他的生命周期<br><img src="http://i.imgur.com/xe4gYmY.jpg" alt=""><br><img src="http://i.imgur.com/ZvJZrIM.jpg" alt=""></p>
<pre><code>// 为addFragment按钮绑定事件监听器
        addFragment.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                LifecycleFragment fragment = new LifecycleFragment();
                getFragmentManager().beginTransaction()
                        .replace(R.id.container, fragment)
                        .commit();
            }
        });
        // 为backFragment按钮绑定事件监听器
        backFragment.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View source)
            {
                SecondFragment fragment = new SecondFragment();
                getFragmentManager().beginTransaction()
                        .replace(R.id.container, fragment)
                        .addToBackStack(&quot;aa&quot;)// 将替换前的Fragment添加到Back栈,按back后会恢复之前的碎片
                        .commit();
            }
        });
        // 为replaceFragment按钮绑定事件监听器
        replaceFragment.setOnClickListener(new OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                SecondFragment fragment = new SecondFragment();
                getFragmentManager().beginTransaction()
                        .replace(R.id.container, fragment)
                        .commit();
            }
        });
</code></pre><p>碎片对应的容器</p>
<pre><code>&lt;LinearLayout 
    android:id=&quot;@+id/container&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;160dp&quot;&gt;
&lt;/LinearLayout&gt;
</code></pre><h1 id="0402_4">1. 启动Activity并返回结果</h1>

<p><a href="#0402">返回目录</a> </p>
<h1 id="0402_5">1. 启动Activity并返回结果</h1>

<p><a href="#0402">返回目录</a> </p>


</body>

</html>

<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->

